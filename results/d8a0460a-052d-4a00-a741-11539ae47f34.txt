[rfc1.txt]:  I. A Summary of the IMP Software
[rfc1.txt]:     Open Questions on the IMP Software
[rfc1.txt]: II. Some Requirements Upon the Host-to-Host Software
[rfc1.txt]:   The software for the ARPA Network exists partly in the IMPs and
[rfc1.txt]:   partly in the respective HOSTs.  BB&N has specified the software of
[rfc1.txt]:   the IMPs and it is the responsibility of the HOST groups to agree on
[rfc1.txt]:   During the summer of 1968, representatives from the initial four
[rfc1.txt]:   sites met several times to discuss the HOST software and initial
[rfc1.txt]:   experiments on the network.  There emerged from these meetings a
[rfc1.txt]:   and Steve Crocker of UCLA, who met during the fall and winter.  The
[rfc1.txt]:   most recent meeting was in the last week of March in Utah.  Also
[rfc1.txt]:   the HOST-IMP interface.
[rfc1.txt]:   I present here some of the tentative agreements reached and some of
[rfc1.txt]:   the open questions encountered.  Very little of what is here is firm
[rfc1.txt]:I.   A Summary of the IMP Software
[rfc1.txt]:   together with its header.  The header is 16 bits and contains the
[rfc1.txt]:   The destination is the numerical code for the HOST to which the
[rfc1.txt]:   message should be sent.  The trace bit signals the IMPs to record
[rfc1.txt]:   status information about the message and send the information back to
[rfc1.txt]:   the NMC (Network Measurement Center, i.e., UCLA).  The spare bits are
[rfc1.txt]:   The link field is a special device used by the IMPs to limit certain
[rfc1.txt]:   HOSTs there are 32 logical full-duplex connections over which messages
[rfc1.txt]:   may be passed in either direction.  The IMPs place the restriction on
[rfc1.txt]:   these links that no HOST can send two successive messages over the
[rfc1.txt]:   same link before the IMP at the destination has sent back a special
[rfc1.txt]:   limits the congestion one HOST can cause another if the sending HOST
[rfc1.txt]:   since the IMP at the destination does not have enough capacity to
[rfc1.txt]:   handle all 32 links simultaneously, the links serve their purpose only
[rfc1.txt]:   if the overload is coming from one or two links.  It is necessary for
[rfc1.txt]:   the HOSTs to cooperate in this respect.
[rfc1.txt]:   The links have the following primitive characteristics.  They are
[rfc1.txt]:   always functioning and there are always 32 of them.
[rfc1.txt]:   By "always functioning," we mean that the IMPs are always prepared to
[rfc1.txt]:   transmit another message over them.  No notion of beginning or ending
[rfc1.txt]:   a conversation is contained in the IMP software.  It is thus not
[rfc1.txt]:   possible to query an IMP about the state of a link (although it might
[rfc1.txt]:   be possible to query an IMP about the recent history of a link --
[rfc1.txt]:   The other primitive characteristic of the links is that there are
[rfc1.txt]:   always 32 of them, whether they are in use or not.  This means that
[rfc1.txt]:   the actual traffic.
[rfc1.txt]:   The objections to the link structure notwithstanding, the links are
[rfc1.txt]:   easily programmed within the IMPs and are probably a better
[rfc1.txt]:   alternative to more complex arrangements just because of their
[rfc1.txt]:   After receiving a message from a HOST, an IMP partitions the message
[rfc1.txt]:   and are the unit of data transmission from IMP to IMP.  A 24 bit
[rfc1.txt]:   cyclic checksum is computed by the transmission hardware and is
[rfc1.txt]:   appended to an outgoing packet.  The checksum is recomputed by the
[rfc1.txt]:   receiving hardware and is checked against the transmitted checksum.
[rfc1.txt]:   Packets are reassembled into messages at the destination IMP.
[rfc1.txt]:Open Questions on the IMP Software
[rfc1.txt]:   4.  Will the IMPs perform code conversion?  How is it to be
[rfc1.txt]:II. Some Requirements Upon the Host-to-Host Software
[rfc1.txt]:   As with any new facility, there will be a period of very light usage
[rfc1.txt]:   until the community of users experiments with the network and begins
[rfc1.txt]:   to depend upon it.  One of our goals must be to stimulate the
[rfc1.txt]:   seems natural to provide the ability to use any remote HOST as if it
[rfc1.txt]:   One of the inherent problems in the network is the fact that all responses
[rfc1.txt]:   from a remote HOST will require on the order of a half-second or so,
[rfc1.txt]:   half-duplex local-echo arrangement, but this would destroy some of the
[rfc1.txt]:   usefulness of the network.  The 940 Systems, for example, have a very
[rfc1.txt]:   When we consider using graphics stations or other sophisticated
[rfc1.txt]:   terminals under the control of a remote HOST, the problem becomes more
[rfc1.txt]:   directly to the remote computer.
[rfc1.txt]:   On these grounds, we would like to see some HOST to HOST checking.
[rfc1.txt]:   Besides checking the software interface, it would also check the
[rfc1.txt]:   HOST-IMP transmission hardware.  (BB&N claims the HOST-IMP hardware
[rfc1.txt]:   will be as reliable as the internal registers of the HOST.  We believe
[rfc1.txt]:   them, but we still want the error checking.)
[rfc1.txt]:   The simplest connection we can imagine is where the local HOST acts as
[rfc1.txt]:   if it is a TTY and has dialed up the remote HOST.  After some
[rfc1.txt]:   consideration of the problems of initiating and terminating such a
[rfc1.txt]:   to break the connection.  When these primitives are invoked, the
[rfc1.txt]:   0 to the remote HOST requesting a connection on the selected link.
[rfc1.txt]:   The operating system in the remote HOST must agree and send back an
[rfc1.txt]:   accepting message over link 0.  In the event both HOSTs select the same
[rfc1.txt]:   essentially the same time, a simple priority scheme will be invoked in
[rfc1.txt]:   which the HOST of lower priority gives way and selects another free
[rfc1.txt]:   link.  One usable priority scheme is simply the ranking of HOSTS
[rfc1.txt]:   by their identification numbers.  Note that both HOSTs are aware that
[rfc1.txt]:   simultaneous requests have been made, but they take complementary
[rfc1.txt]:   actions: The higher priority HOST disregards the request while the
[rfc1.txt]:   lower priority HOST sends both an acceptance and another request.
[rfc1.txt]:   The connection so established is a TTY-like connection in the
[rfc1.txt]:   pre-log-in state.  This means the remote HOST operating system will
[rfc1.txt]:   initially treat the link as if a TTY had just called up.  The remote
[rfc1.txt]:   HOST will generate the same echos, expect the same log-in sequence and
[rfc1.txt]:   look for the same interrupt characters.
[rfc1.txt]:   consider the transmission of a large file.  The first is that some
[rfc1.txt]:   special buffering techniques are often employed, and these are
[rfc1.txt]:   We therefore define another class of connection to be used for the
[rfc1.txt]:   transmission of files or other large volumes of data.  To initiate
[rfc1.txt]:   TTY-like link must request the establishment of a file-like connection
[rfc1.txt]:   parallel to the TTY-like link.  Again the priority scheme comes into
[rfc1.txt]:   play, for the higher priority HOST sends a message over link 0 while
[rfc1.txt]:   the lower priority HOST waits for it.  The user level programs are, of
[rfc1.txt]:   course, not concerned with this.  Selection of the free link is done
[rfc1.txt]:   by the higher priority HOST.
[rfc1.txt]:   File-like links are distinguished by the fact that no searching for
[rfc1.txt]:   for the higher data rates takes place.
[rfc1.txt]:   Each HOST operating systems must provide at least the following
[rfc1.txt]:   checksum in its body, that is transparent to the IMP.  For a checksum
[rfc1.txt]:   then circularly shifted right one bit.  The right circular shift every
[rfc1.txt]:   1152 bits is designed to catch errors in message reassembly by the IMPs.
[rfc1.txt]:   use of the network is to be carried out.  Specifically, we are
[rfc1.txt]:   concerned with the fact that as some sites a great deal of work has
[rfc1.txt]:   gone into making the computer highly responsive to a sophisticated
[rfc1.txt]:   for trivial echo-like responses degrade the interaction to the point
[rfc1.txt]:   of making the sophistication of the console irrelevant.
[rfc1.txt]:   screen.  The program the user is talking typing into accumulates a
[rfc1.txt]:   string of characters until a carriage return is encountered and then
[rfc1.txt]:   it processes the string.  While characters are being typed, it
[rfc1.txt]:   displays the characters on the screen.  When a rubout character is
[rfc1.txt]:   typed, it deletes the previous non-rubout character.  If the user
[rfc1.txt]:   carriage-return, he has made nine keystrokes.  If each of these
[rfc1.txt]:   A better solution would be to have the front-end of the remote program
[rfc1.txt]:   -- that is the part scanning for <- and <CR> -- be resident in our
[rfc1.txt]:   sent, i.e., H E L P <CR>, and the screen would be managed locally.
[rfc1.txt]:   terminal and how the terminal is to respond to inputs from its
[rfc1.txt]:   keyboard, Lincoln Wand, etc.  Then, as a part of the initial protocol,
[rfc1.txt]:   the remote HOST would send to the local HOST, the source language text
[rfc1.txt]:   of the program which controls the console.  This program would have
[rfc1.txt]:   been by the subsystem designer in DEL, but will be compiled locally.
[rfc1.txt]:   diagrams show the sequence of actions.
[rfc1.txt]:c.  After Receipt and Compilation of the DEL program
[rfc1.txt]:   1.  If the IMPs do code conversion, the checksum will not be correct.
[rfc1.txt]:   2.  The procedure for requesting the DEL front end is not yet
[rfc1.txt]:   SRI is currently modifying their on-line retrieval system which will
[rfc1.txt]:   be the major software component on the Network Documentation Center so
[rfc1.txt]:   that it can be operated with model 35 teletypes.  The control of the
[rfc1.txt]:   and use NLS through the DEL program.
[rfc1.txt]:         [ into the online RFC archives by Celeste Anderson 3/97 ]
[rfc10.txt]:The Network Working Group (NWG) is concerned with the HOST software, the
[rfc10.txt]:strategies for using the network, and initial experience with the network.
[rfc10.txt]:Documentation of the NWG's effort is through notes such as this.  Notes
[rfc10.txt]:the HOST software or other aspect of the network.  Notes are encouraged to
[rfc10.txt]:be timely rather than polished.  Philosophical positions without examples
[rfc10.txt]:or other specifics, specific suggestions or implementation techniques
[rfc10.txt]:These standards (or lack of them) are stated explicitly for two reasons.
[rfc10.txt]:First, there is a tendency to view a written statement as ipso facto
[rfc10.txt]:authoritative, and we hope to promote the exchange and discussion of 
[rfc10.txt]:considerably less than authoritative ideas.  Second, there is a natural
[rfc10.txt]:Every NWG note should bear the following information:
[rfc10.txt]:One copy only will bve sent from the author's site to:
[rfc10.txt]:Below are the most current addresses I have.  Please correct as necessary.
[rfc11.txt]:                   Implementation of the Host - Host
[rfc11.txt]:   This technical note concentrates upon (1) the HOST-HOST procedures
[rfc11.txt]:   and (2) the implementation of the corresponding programs in GORDO
[rfc11.txt]:   (Operating System of the UCLA HOST).
[rfc11.txt]:   The first section is closely related to the BBN reports No. 1822 and
[rfc11.txt]:   1763[1] and specifies the HOST functions for exchanging messages.  It
[rfc11.txt]:   The second section is software oriented; it explains how the HOST
[rfc11.txt]:   simultaneously be able to utilize the network by time-sharing its
[rfc11.txt]:   This implies that within each HOST operating system, there must exist
[rfc11.txt]:   a special program that multiplexes outgoing messages from the users
[rfc11.txt]:   into the network and distributes incoming messages to the appropriate
[rfc11.txt]:   users.  We will call this special program the Network program.
[rfc11.txt]:   It is convenient to consider the Network as a black box - a system
[rfc11.txt]:   communicating messages between remote users rather than between pairs
[rfc11.txt]:         One of the purposes of the Network program is to serve the
[rfc11.txt]:         users in establishing, identifying, and maintaining these
[rfc11.txt]:         one for transmitting, the other for receiving.
[rfc11.txt]:         Those links, called logical links, are established by the
[rfc11.txt]:         Network programs and used by them.
[rfc11.txt]:         connections are carried out by the Network program.
[rfc11.txt]:         One of the advantages to define a connection as a pair of
[rfc11.txt]:         directional links is that a HOST will have the capability to
[rfc11.txt]:         Further on through this paper we will not use any more the
[rfc11.txt]:         attribute logical when referring either to links or
[rfc11.txt]:   In order to reach a high flexibility in utilizing the Network there
[rfc11.txt]:   is advantage to classify the connections.
[rfc11.txt]:      of HOST[s], e.g., if the Network includes x HOST[s], there are at
[rfc11.txt]:      the establishment/deletion of standard connections.  (See 2.4.2)
[rfc11.txt]:      Note here that this control connection is the only connection
[rfc11.txt]:      which is not used by the HOST users.
[rfc11.txt]:      Let us describe now the standard connections.
[rfc11.txt]:            * Is unique between a pair of users and is the first to be
[rfc11.txt]:               - Echoes are generated by the remote HOST;
[rfc11.txt]:            * Is used either for binary or character transmission.
[rfc11.txt]:   The HOST[s] communicate with each other via messages.  A message may
[rfc11.txt]:   vary in length up to 8095 bits (See down below the structure).
[rfc11.txt]:   Larger transmission must therefore be broken up by HOST users into a
[rfc11.txt]:      It includes the following:
[rfc11.txt]:      (2) A marketing (32 bits when sent by the Sigma 7) for starting a
[rfc11.txt]:      (3) The message text (Max: 8015 bits for the Sigma 7).  It mostly
[rfc11.txt]:          information for use by the Network programs.  (Control
[rfc11.txt]:      (4) A checksum (16 bits).  Its purpose is to check, at the HOST
[rfc11.txt]:          level, the right transmission of a message.  (Changes in bit
[rfc11.txt]:          delineating message ends.  (At transmission the hardware takes
[rfc11.txt]:          care of the padding.)
[rfc11.txt]:      This checksum is computed on the whole message including any
[rfc11.txt]:      marking, but excluding the 32 bit leader and any padding.  To
[rfc11.txt]:      compute the checksum:
[rfc11.txt]:      1.  Consider the message to be padded with zeroes to a length of
[rfc11.txt]:      2.  Section the 8640 bits into six 1440-bit segments, S0, S1...S5.
[rfc11.txt]:   The number C is the checksum.  The reason the Ci are rotated by i
[rfc11.txt]:    [Figure 2 - Format of a message sent by the Sigma 7 - see PDF file]
[rfc11.txt]:   From what has been discussed until here, the Network appears to a
[rfc11.txt]:   use of these connections.
[rfc11.txt]:   First, we are going to describe the set of transactions that a user
[rfc11.txt]:   should be able to access for utilizing the connection facilities.
[rfc11.txt]:   Then, we are going to explain the role of the Network program for the
[rfc11.txt]:   execution of these transactions.  This will cover a HOST-HOST
[rfc11.txt]:   For explanation purposes those transactions are represented, at the
[rfc11.txt]:   user level, in the form of subroutine calls and parameters.  However,
[rfc11.txt]:   this does not imply at all that the implementation will closely
[rfc11.txt]:   follow this pattern.  (We are more involved here with the description
[rfc11.txt]:   than the implementation aspect, see chapter 3.)
[rfc11.txt]:   Listed below are the descriptions of subroutines that could be at
[rfc11.txt]:   transmitting/receiving data over them.  This set of subroutines can
[rfc11.txt]:   be considered as a kind of interface between the user level and the
[rfc11.txt]:              transmitted back by the remote HOST for checking purpose),
[rfc11.txt]:        CONNECTID:  Connection identification #, i.e., the
[rfc11.txt]:                    identification of the corresponding primary
[rfc11.txt]:             to the order in which it has been established.  (The first
[rfc11.txt]:             auxiliary opened is referred to by NO=1, the second by
[rfc11.txt]:        BUFFADDR:  Buffer address of the message to be transmitted.
[rfc11.txt]:            connections in use by the user, included the primary link,
[rfc11.txt]:        NO:  In case of N different from zero this number indicates the
[rfc11.txt]:   The HOST-HOST protocol is carried out by the Network programs.  It
[rfc11.txt]:   mainly involves the execution of the previous transactions (initiated
[rfc11.txt]:   connections and consists in exchanging control messages over the
[rfc11.txt]:   a regular message; it only differs from it by the text which is for
[rfc11.txt]:   transmission control procedures implemented in the IMP computers.  We
[rfc11.txt]:   are here at the HOST level (Network programs), and therefore control
[rfc11.txt]:   the IMP[s] like regular messages.
[rfc11.txt]:   Consider now the previous transactions and describe for each of them
[rfc11.txt]:      opening a primary connection, starts a dialogue with the HOST
[rfc11.txt]:        (i)  HOST(x) sends the following control message:
[rfc11.txt]:                      This link # has been determined by the HOST(x)
[rfc11.txt]:        (ii) HOST(y) acknowledges by sending back the following control
[rfc11.txt]:             ENQ PRIM 0 1 2:  Same meaning as above.  This part of the
[rfc11.txt]:             0 1 5:   Incoming link #.  It follows the same pattern as
[rfc11.txt]:                      the outgoing link #.  This link # has been
[rfc11.txt]:                      determined by the HOST(y) Network program.
[rfc11.txt]:                      Now the connection is established; it will use
[rfc11.txt]:                      state, i.e., the remote HOST(y) expects its
[rfc11.txt]:         By means of TRANSM subroutines referring to the primary
[rfc11.txt]:         connection, the HOST(x) user is able to sign-in into the
[rfc11.txt]:         HOST(y) operating system and then to call for the URSA program
[rfc11.txt]:         The Network programs at both ends will use the link #12 and #15
[rfc11.txt]:         messages are exchanged over the control link.
[rfc11.txt]:         Now the auxiliary connection is established, it will use links
[rfc11.txt]:         By means of TRANSM subroutines referring to the auxiliary
[rfc11.txt]:         connection, the users at both ends can exchange data:
[rfc11.txt]:         a CLOSE subroutine and then the Network programs at both ends
[rfc11.txt]:         indicating, in a coded form, why the previous block has been
[rfc11.txt]:         Remark 2 - On each of the above illustrations (arrows) only the
[rfc11.txt]:         leader, marking, padding...) are exchanged over these links.
[rfc11.txt]:   outline below some of the characteristics relevant to our paper.
[rfc11.txt]:   which compose the body of the file.  A directory consists of a number
[rfc11.txt]:   of entries that point to either files or other directories.
[rfc11.txt]:      environment.  In other words a process is a program which is known
[rfc11.txt]:      and controlled by the GORDO scheduler.
[rfc11.txt]:   *  The space a process can refer to is the Virtual Space of 128k word
[rfc11.txt]:      length.  A part (8k) of it is reserved for the operating system,
[rfc11.txt]:      the other part (120k) is directly accessed by the user.  This
[rfc11.txt]:      later may fill or modify its part of the virtual space upon
[rfc11.txt]:         SLEEP   for putting asleep another process (or itself)
[rfc11.txt]:         COUPLE  for coupling a page from the file space to the virtual
[rfc11.txt]:   Remark:  Through this note the words process and program are used
[rfc11.txt]:   Figure 4 illustrates the overall organization.
[rfc11.txt]:   The system is based upon two main programs: the "Network" and the
[rfc11.txt]:   The Handler is an I/O interrupt routine closely related to the IMP-
[rfc11.txt]:   HOST hardware interface.  It serves the Network process in
[rfc11.txt]:   The Network process carries out most of the work.
[rfc11.txt]:   Its main function is to satisfy the users' requests for opening/
[rfc11.txt]:   *  it establishes, identifies, and breaks the links upon using the
[rfc11.txt]:   *  it is aware of the presence of new users upon exploring the
[rfc11.txt]:   *  it communicates with the Handler by means of a shared page (I/O
[rfc11.txt]:      communication page) which contains the I/O communication buffers.
[rfc11.txt]:            It is a bit table indicating the free outgoing links.  It
[rfc11.txt]:            has the following characteristics:
[rfc11.txt]:            *  Coupling: Coupled to the Network process virtual space.
[rfc11.txt]:            *  Specific feature:  Throughout the whole table no more
[rfc11.txt]:                                  figure corresponds to the maximum
[rfc11.txt]:                                  is the number of remote HOST[s]).
[rfc11.txt]:            This table keeps track of all the connections' environment.
[rfc11.txt]:            It has the following characteristics:
[rfc11.txt]:            *  Coupling:  Couples to the Network process virtual space
[rfc11.txt]:                        connection #.  See 3.4 the way it is handled.
[rfc11.txt]:                                    with the connection pages (See 3.3.2
[rfc11.txt]:                                    connection it contains the outgoing
[rfc11.txt]:                                    the information required for
[rfc11.txt]:            This table keeps track of all the incoming (input) links and
[rfc11.txt]:            so is closely related to the CONNECT table.
[rfc11.txt]:   It has the following characteristics:
[rfc11.txt]:   *  Coupling:  Coupled to the Network process virtual space.
[rfc11.txt]:                        upon the incoming link # and the remote HOST #.
[rfc11.txt]:                                    momentarily memorizing the
[rfc11.txt]:                                    the next connection.  See 3.4 the
[rfc11.txt]:                                    incoming link it contains the
[rfc11.txt]:                                    indirectly the user identification
[rfc11.txt]:                                    to which the message should be
[rfc11.txt]:      All the pages that are now to be described contain two buffers
[rfc11.txt]:      (input and output).  These buffers are used for either passing
[rfc11.txt]:      The size of each of these buffers should at least be equal to that
[rfc11.txt]:      253 words (8096 bits) so that both of the buffers are included
[rfc11.txt]:      within one page (512 words).  The 6 remaining words of the page
[rfc11.txt]:         This I/O communication page is used as an interface between the
[rfc11.txt]:         Handler and the Network program.
[rfc11.txt]:         In the buffers of this page the messages are assembled (input)
[rfc11.txt]:         or de-assembled (output) word by word by the Handler, e.g., a
[rfc11.txt]:         "ready to go" message, sorted by the Network program in the
[rfc11.txt]:         output buffer, is shipped out word by word by the Handler.
[rfc11.txt]:         *  Coupling:  Coupled to the Network process virtual space
[rfc11.txt]:         *  Specific feature: * The input buffer is filled by the
[rfc11.txt]:                                by the Network program
[rfc11.txt]:                              * Vice versa for the output buffer
[rfc11.txt]:         *  These pages shared between the network and the user
[rfc11.txt]:            the messages back and forth, and (2) exchanging control
[rfc11.txt]:            the
[rfc11.txt]:         *  Specific feature 1: - The input buffer is filled by the
[rfc11.txt]:                                  Network and emptied by the user.
[rfc11.txt]:                                - Vice versa for the output buffer.
[rfc11.txt]:                                  requests are transmitted to the
[rfc11.txt]:         *  This page allows the Network and the Handler programs to
[rfc11.txt]:         an overlapping.  For instance, when the Handler is busy
[rfc11.txt]:         transmitting a message to the hardware, the Network program can
[rfc11.txt]:         format (leader, marking, etc.) the reset message to be shipped
[rfc11.txt]:         out, so that it can reinitiate the Handler as soon as it is
[rfc11.txt]:         *  Coupling:  Coupled to the Network process virtual space
[rfc11.txt]:         the system, the Network stores momentarily the incoming message
[rfc11.txt]:         in one of the buffer of the emergency ring.  (If this ring is
[rfc11.txt]:         During emission all operations are synchronized with the
[rfc11.txt]:         RFNM[s], therefore such procedures need not be provided.  (The
[rfc11.txt]:         received the RFNM of the previous transmitted message.)
[rfc11.txt]:      It is an I/O interrupt routine which drives the IMP/HOST hardware
[rfc11.txt]:      *  Location:  Core resident.  The Handler is in the same memory
[rfc11.txt]:                    zone as the operating system and can be considered
[rfc11.txt]:      *  Initiation: By the IMP-HOST hardware interrupt.  This interrupt
[rfc11.txt]:                     is triggered either:
[rfc11.txt]:                       completely sent to the IMP
[rfc11.txt]:                       completely received from the IMP
[rfc11.txt]:                     * during idle time when the hardware received
[rfc11.txt]:                       either a 'start input' or 'start output' order
[rfc11.txt]:                       from the Sigma 7 CPU.  Those orders are issued by
[rfc11.txt]:                       the Network program for provoking interrupts back
[rfc11.txt]:                       (consequently for indirectly initiating the
[rfc11.txt]:      *  Main functions: * Empties the output buffer upon transmitting
[rfc11.txt]:                           its content (outgoing message to the IMP.
[rfc11.txt]:                           driving the HOST-IMP hardware.
[rfc11.txt]:                         * Fills the input buffer with data received
[rfc11.txt]:                           driving the HOST-IMP hardware.
[rfc11.txt]:                         * Wakes up the Network program when any of the
[rfc11.txt]:      This program serves the user for opening/closing connections and
[rfc11.txt]:      transmitting/receiving messages.  It uses the Handler as an aid
[rfc11.txt]:      for inter-facing with the hardware.
[rfc11.txt]:      For the GORDO point of view it is a regular process and treated as
[rfc11.txt]:                      issued either by a user process or by the Handler.
[rfc11.txt]:                           established/released; it then notifies back
[rfc11.txt]:                           the users.
[rfc11.txt]:                         * Insures the processing of incoming control
[rfc11.txt]:                           (the messages are stored there by users),
[rfc11.txt]:                           formats them (adds leader, marking,
[rfc11.txt]:                           checksum..), and passes them along to the
[rfc11.txt]:                           the opposite of the above operation.  The
[rfc11.txt]:                           users to which the messages should be
[rfc11.txt]:                           delivered are identified through the leaders.
[rfc11.txt]:                            for indirectly initiating the Handler).
[rfc11.txt]:   The detailed software procedures are given on the flowcharts attached
[rfc11.txt]:   However, to get a quick understanding of the implementation we list
[rfc11.txt]:   Consider some of the transactions at user's disposal (See 2.4) and
[rfc11.txt]:   point out the basic software procedures they imply.  For each case we
[rfc11.txt]:   will delineate (i) what the user program does and (ii) what the
[rfc11.txt]:         (i)  What the user program does[1]:
[rfc11.txt]:              *  it stores in the Network mail box directory the name of
[rfc11.txt]:              *  it couples the first page of this file to its virtual
[rfc11.txt]:                 the remote HOST #, e.g., (i));
[rfc11.txt]:              *  it wakes up the Network process;
[rfc11.txt]:         (ii) What the Network program does:
[rfc11.txt]:              *  it explores the Network mail box directory and accesses
[rfc11.txt]:                 the file DATA;
[rfc11.txt]:              *  it couples the first page of this file to its virtual
[rfc11.txt]:                 be kth in the shared zone; k is the internal connection
[rfc11.txt]:              *  it explores the ith slot of the new HOST table (See
[rfc11.txt]:                 3.3.1.1 (a)) and selects the first bit = 0, e.g., the
[rfc11.txt]:                 (alpha)th bit; alpha corresponds to the outgoing link
[rfc11.txt]:                 (i), outgoing link # (alpha)) in the kth slot of the
[rfc11.txt]:              *  it momentarily stores the connection # (k) in the INPUT
[rfc11.txt]:                 in this table (Hashing the key value:  "outgoing link #
[rfc11.txt]:              *  it prepares the message text ENQ PRIM 0 0 a and formats
[rfc11.txt]:              *  it checks the Handler state (bit in I/O locked page).
[rfc11.txt]:                 If the Handler is free, it stores the 'ready to go'
[rfc11.txt]:                 control message in the output buffer of the I/O locked
[rfc11.txt]:                 page, initiates the Handler, and goes to sleep.  Else
[rfc11.txt]:   After a while the Handler wakes up the Network process because it has
[rfc11.txt]:   received a complete message.  We suppose this message be the control
[rfc11.txt]:   message sent by the remote HOST for acknowledging the establishment
[rfc11.txt]:   of the connection.  The message text should be:
[rfc11.txt]:   where beta is the incoming link #.  (See 2.4.2)
[rfc11.txt]:   Let's see now what the Network program does when receiving the above
[rfc11.txt]:              *  it retrieves the connection # previously stored in the
[rfc11.txt]:                 INPUT LINK table upon re-hashing the same key value
[rfc11.txt]:              *  it creates an entry in the INPUT LINK table for the
[rfc11.txt]:                 incoming link.  For so doing it hashes the key value:
[rfc11.txt]:                 "incoming flag".  In this entry it stores the HOST #
[rfc11.txt]:                 (i), the incoming link # (beta), and connection # (k);
[rfc11.txt]:              *  it updates the kth slot of the CONNECT table in storing
[rfc11.txt]:                 the incoming link # (beta);
[rfc11.txt]:              *  it turns on the 'net-user' bit in the kth shared page
[rfc11.txt]:                 (page corresponding to the primary connection that has
[rfc11.txt]:                 just been opened) and wakes up the user process;
[rfc11.txt]:         (i)  What the user program does[1].
[rfc11.txt]:              *  it stores the message text in the output buffer of the
[rfc11.txt]:              *  it turns on the 'user-net' bit of this page and wakes
[rfc11.txt]:                 up the Network process;
[rfc11.txt]:         (ii) What the Network program does:
[rfc11.txt]:                 sequence the connection shared pages and selects the
[rfc11.txt]:                 be the selected page # on the shared list, K is the
[rfc11.txt]:              *  it determines the request type in testing the 'request
[rfc11.txt]:                 bits' of the shared page k.  It finds out that it is a
[rfc11.txt]:              *  it takes the message text from the output buffer of the
[rfc11.txt]:                 transmits to the Handler in a very similar way as above
[rfc11.txt]:      [1]  Remark:  In a first phase the user will directly write the
[rfc11.txt]:          [ into the online RFC archives by Bob German 8/99 ]
[rfc12.txt]:   The following flow diagrams were extracted from the logic diagrams
[rfc12.txt]:   indicate the logical sequence of hardware operations which occur
[rfc12.txt]:   within the IMP-HOST interface.  The logic names appearing in the
[rfc12.txt]:   blocks correspond to the logic elements found in Appendix B.
[rfc12.txt]:             [ into the online RFC archives by Lorrie Shiota]
[rfc13.txt]:purpose.  Figure 1 shows the format:
[rfc13.txt]:      [ into the online RFC archives by Michael Brunnbauer 1/97 ]
[rfc15.txt]:   Note 11) for inclusion in the monitor systems of the respective
[rfc15.txt]:   HOSTS.  These primitives are at the level of system calls: SPOP's or
[rfc15.txt]:   BRS's on the 940; UUO's on the PDP-10.  Presumably these UUO's are
[rfc15.txt]:   network access from the terminal is desirable.  A sub-system called
[rfc15.txt]:   "Telnet" is proposed which is a shell program around the network
[rfc15.txt]:   remote host to function as a teletype at the serving host.
[rfc15.txt]:   primitives for inclusion in the operating systems of the respective
[rfc15.txt]:   The details  and terminology are defined by Deloche and others in
[rfc15.txt]:   programmers, and are most likely a part of the resident monitor,
[rfc15.txt]:   rather than the swappable executive.
[rfc15.txt]:   subsystem program at each HOST which makes the network immediately
[rfc15.txt]:   accessible from the teletype without special programming.  Subsystems
[rfc15.txt]:   will be developed in time, but this basic one will render the early
[rfc15.txt]:   A user at Utah is sitting at a teletype dialed into the University's
[rfc15.txt]:   dual PDP-10's.  He wishes to operate the CAL sub-system on the 940 at
[rfc15.txt]:                                       the TELNET subsystem.
[rfc15.txt]:                                       input from the user.
[rfc15.txt]:    ------------------                 the appropriate system call
[rfc15.txt]:                                       another foreign user;
[rfc15.txt]:                                       status word kept in the PDP-10
[rfc15.txt]:   Characters typed on the user's teletype are transmitted unaltered
[rfc15.txt]:   through the PDP-10 (user Host) and on to the 940 (serving HOST.)
[rfc15.txt]:   required between the UCLA Sigma 7 and the PDP-10, for example).
[rfc15.txt]:                                       typed by the user are
[rfc15.txt]:                                       the PDP-10, though not used
[rfc15.txt]:   The user wishes to load a CAL file into 940 CAL from the file system
[rfc15.txt]:                                       and the file from UTAH.
[rfc15.txt]:   #NETWRK: <- DSK:MYFILE.CAL<CR>      The user types the prescribed
[rfc15.txt]:                                       the TELNET command, to send
[rfc15.txt]:                                       the desired file to SRI on an
[rfc15.txt]:   it does very little.  It effectively establishes a shunt in the user
[rfc15.txt]:   HOST between the remote user and the serving HOST.  Telnet commands
[rfc15.txt]:                                       shunted through to the serving
[rfc15.txt]:                                       host, but sent instead to the
[rfc15.txt]:                                       Telnet program in the user's
[rfc15.txt]:   This escape character is not the same as the user's host
[rfc15.txt]:   CONNECT TO __________________<CR>   The official site name of the
[rfc15.txt]:                                       connection.  If the attempt is
[rfc15.txt]:                                       successful, the following
[rfc15.txt]:                                       the user's local machine.  The
[rfc15.txt]:                                       connection places the user in
[rfc15.txt]:                                       the pre-logged in state at
[rfc15.txt]:                                       the serving HOST.
[rfc15.txt]:   LOGOUT<CR>                          Telnet issues the logout command
[rfc15.txt]:                                       sequence to the serving HOST.
[rfc15.txt]:                                       If the user simply rubs out and
[rfc15.txt]:                                       kills his PDP-10 job, the
[rfc15.txt]:                                       PDP-10 will indicate to the 940
[rfc15.txt]:                                       that the connection is closed.
[rfc15.txt]:                                       whatever they do when a normal
[rfc15.txt]:                                       connections from the
[rfc15.txt]:                                       to the serving HOST.
[rfc15.txt]:        On the 940 this is:
[rfc15.txt]:        On the PDP-10:
[rfc15.txt]:   These TELNET commands are accepted when the TELNET subsystem is first
[rfc15.txt]:   entered or following the declared escape character.
[rfc15.txt]:   Given the basic system primitives, the TELNET subsystem at the user
[rfc15.txt]:   host and a manual for the serving host, the network can be
[rfc15.txt]:   of-line, in place of the original handwritten arrows.]
[rfc15.txt]:         [ into the online RFC archives by Sergio Kleiman  9/00  ]
[rfc17.txt]:            the HOST network program must generate a dummy message
[rfc17.txt]:            merely to keep the link open?
[rfc17.txt]:    1969 Jul, says on page 2: "The principal function of the (IMP)
[rfc17.txt]:    generates an RFNM and then discovers it cannot, for some reason,
[rfc17.txt]:    complete timely delivery of the last received message to its HOST?
[rfc17.txt]:    IMP constraint upon HOSTs that they must accept incoming messages
[rfc17.txt]:    into network (see, e.g., Page 17, BBN 1822) therefore why the
[rfc17.txt]:    Normally the times involved differ by many orders of magnitude but a
[rfc17.txt]:          [ into the online RFC archives by Marc Blanchett 3/00 ]
[rfc17.txt]:   the middle of transmitting or receiving a message.  When the Host
[rfc17.txt]:   transmits a message on a link for which an entry is not in the link
[rfc17.txt]:   table, one will simply be inserted there.  There is no need for
[rfc17.txt]:   effectively always open.  Only if the link table becomes full
[rfc17.txt]:   to occur) is there a possibility of resulting delay.
[rfc17.txt]:   inconsistent with the link entry deletion procedure.  A link is
[rfc17.txt]:   blocked when the first access of the link table is made during
[rfc17.txt]:   transmission from the source IMP and is unblocked when the RFNM
[rfc17.txt]:   delays was only intended to have hardware implications insofar as the
[rfc17.txt]:   between the Host and the IMP.
[rfc17.txt]:   A RFNM is returned from the destination IMP to the source IMP when a
[rfc17.txt]:   message reaches the head of the destination IMP's output queue to the
[rfc17.txt]:   Host (i.e. just before a message is sent to the Host).  If a
[rfc17.txt]:   destination IMP cannot then deliver that full message to the Host, at
[rfc17.txt]:   most one more message may possibly arrive at that IMP due to the
[rfc17.txt]:   premature release of the RFNM.  The new message will subsequently
[rfc17.txt]:   take its place at the end of the output queue to the Host thus
[rfc17.txt]:   guaranteeing the preservation of the proper message arrival sequence.
[rfc17.txt]:   use during initiation of communication between the Host and its IMP.
[rfc17.txt]:   period, but the first received message after IMP startup or after the
[rfc17.txt]:   Host ready indicator has gone on, may be discarded by the IMP.  We do
[rfc17.txt]:   not require a Host to be prepared to repeat transmissions into the
[rfc17.txt]:          [ into the online RFC archives by Marc Blanchett 3/00 ]
[rfc17a.txt]:   the middle of transmitting or receiving a message.  When the Host
[rfc17a.txt]:   transmits a message on a link for which an entry is not in the link
[rfc17a.txt]:   table, one will simply be inserted there.  There is no need for
[rfc17a.txt]:   effectively always open.  Only if the link table becomes full
[rfc17a.txt]:   to occur) is there a possibility of resulting delay.
[rfc17a.txt]:   inconsistent with the link entry deletion procedure.  A link is
[rfc17a.txt]:   blocked when the first access of the link table is made during
[rfc17a.txt]:   transmission from the source IMP and is unblocked when the RFNM
[rfc17a.txt]:   delays was only intended to have hardware implications insofar as the
[rfc17a.txt]:   between the Host and the IMP.
[rfc17a.txt]:   A RFNM is returned from the destination IMP to the source IMP when a
[rfc17a.txt]:   message reaches the head of the destination IMP's output queue to the
[rfc17a.txt]:   Host (i.e. just before a message is sent to the Host).  If a
[rfc17a.txt]:   destination IMP cannot then deliver that full message to the Host, at
[rfc17a.txt]:   most one more message may possibly arrive at that IMP due to the
[rfc17a.txt]:   premature release of the RFNM.  The new message will subsequently
[rfc17a.txt]:   take its place at the end of the output queue to the Host thus
[rfc17a.txt]:   guaranteeing the preservation of the proper message arrival sequence.
[rfc17a.txt]:   use during initiation of communication between the Host and its IMP.
[rfc17a.txt]:   period, but the first received message after IMP startup or after the
[rfc17a.txt]:   Host ready indicator has gone on, may be discarded by the IMP.  We do
[rfc17a.txt]:   not require a Host to be prepared to repeat transmissions into the
[rfc17a.txt]:          [ into the online RFC archives by Marc Blanchett 3/00 ]
[rfc18.txt]:It is suggested that link 1 be used for the HOST-HOST control link
[rfc19.txt]:among the HOST systems to be nodes in the ARPA IMP network.  The slower
[rfc19.txt]:of these, of which our 360/50 system with 2303 drump swap store is an
[rfc19.txt]:example, might improve the utility of the network not only for
[rfc19.txt]:themselves but for all nodes if the two protocol suggestions of this
[rfc19.txt]:   now calls for delivery of messages from IMP to HOST in the order in
[rfc19.txt]:   which the IMP received them.  This may lead to wasted swapping if,
[rfc19.txt]:   for example, the IMP has messages for its HOST's timeshare users A
[rfc19.txt]:   would have to be swapped out, A in, and the first message accepted--
[rfc19.txt]:   If the HOST could a) read the IMP's queue of waiting messages and b)
[rfc19.txt]:   accept them in the order it found most effective, then a new
[rfc19.txt]:2. Core-to-core transfers between HOSTS.  At another level, perhaps not
[rfc19.txt]:   programs in core for the duration of a multi-message file transfer
[rfc19.txt]:   on an auxiliary connection.  This could greatly reduce the time to
[rfc19.txt]:   the numbers mitigate possible advantages of this approach to some
[rfc19.txt]:   extent:  if we assume a 50 kilobit/sec line and support further that
[rfc19.txt]:   core for more than about 2 seconds.  If this is the case, then the
[rfc19.txt]:   method would be applicable only for the rather limited range of file
[rfc19.txt]:   sizes of 2-16 messages.  Nevertheless, the time to move a large file
[rfc19.txt]:         [ into the online RFC archives by Alex Portnoy 1/97 ]
[rfc2.txt]:      the network
[rfc2.txt]:         the network. Thus, if there are n HOSTs on the network, there
[rfc2.txt]:      the purposes of:
[rfc2.txt]:         1a2c Passing interrupts regarding the status of links and/or
[rfc2.txt]:         programs using the links
[rfc2.txt]:      1a3 Imps in the network may automatically trace all messages sent
[rfc2.txt]:      of the other HOSTs on the network.
[rfc2.txt]:         1b1a The primary link must be the first link established
[rfc2.txt]:         between a HOST user and another HOST.
[rfc2.txt]:         a normal data-phone or direct line by the remote HOST, i.e. the
[rfc2.txt]:         information to the remote HOST, e.g. it will be used for
[rfc2.txt]:         logging in to the remote host (using the remote hosts standard
[rfc2.txt]:         1c1a These links may be used for either binary or character
[rfc2.txt]:         1c1b Auxilliary links are local to the sub-system which
[rfc2.txt]:         establishes them, and therefore are closed when that subsystem
[rfc2.txt]:         2a2a The status of the control link should reflect the
[rfc2.txt]:         relationship between the HOSTs.
[rfc2.txt]:      the monitor
[rfc2.txt]:         2b1a The network identification number of the HOST to be linked
[rfc2.txt]:         to must be included in the call
[rfc2.txt]:         particular HOST will be regarded as an error, and the request
[rfc2.txt]:            transmission of data over the primary links and control
[rfc2.txt]:            2b1d3 A then waits for:
[rfc2.txt]:            2b1d4 If a communication regarding the link is received from
[rfc2.txt]:               2b1d4a A verification of the link from B.
[rfc2.txt]:                  2b1d4a1 This results in a successful return from the
[rfc2.txt]:                  monitor to the requestor. The link number is returned
[rfc2.txt]:                  to the requestor, and the link is established.
[rfc2.txt]:               2b1d4b A request from B to establish the link. This
[rfc2.txt]:               means: that B is trying to establish the same link as A
[rfc2.txt]:                  2b1d4b1 If the network ID number of A(Na) is greater
[rfc2.txt]:                  than that of B(Nb), then A ignores the request, and
[rfc2.txt]:                  continues to await confirmation of the link from B.
[rfc2.txt]:                  2b1d4b2 If, on the other hand, Na<Nb, A:
[rfc2.txt]:                     2b1d4b2a Honors the request from B to establish the
[rfc2.txt]:                     2b1d4b2c Aborts its own request, and repeats the
[rfc2.txt]:               2b1d4c Some other communication from B regarding the
[rfc2.txt]:                  either:
[rfc2.txt]:                     concerning the attempted connection
[rfc2.txt]:                     2b1d4c2b Consider the state of HOST B to be in
[rfc2.txt]:               2b1d5 If no communication regarding the link is received
[rfc2.txt]:               from B in the prescribed amount of time, HOST B is
[rfc2.txt]:      2c1 Auxilliary links are established by a call to the monitor from
[rfc2.txt]:         2c1a The request must specify pertinent data about the desired
[rfc2.txt]:         link to the monitor
[rfc2.txt]:            2c1a1 The number of the primary link to B.
[rfc2.txt]:         program in each of the HOSTs (A and B).
[rfc2.txt]:         2c1c If Na > Nb, then HOST A proceeds to establish a link to
[rfc2.txt]:         HOST B in the manner outlined above (getlink).
[rfc2.txt]:         2c1d If Na<Nb, then A waits:
[rfc2.txt]:            2c1d1 For HOST B to establish the link (after looking to see
[rfc2.txt]:            if B has already established the corresponding link).
[rfc2.txt]:               2c1d2a This means that HOST B did not respond to the
[rfc2.txt]:               specifiy the amount of time to wait for the timeout.
[rfc2.txt]:   3a All messages sent over the network will be error checked initally
[rfc2.txt]:         fields in the string to be checked serially, and adding the
[rfc2.txt]:         carry bit into the lowest bit position of the sum.
[rfc2.txt]:            they are folded appropiately after the addition.
[rfc2.txt]:                  3b1a2a Using this scheme, it is assumed that, if there
[rfc2.txt]:                  are n fields, the carries from the first n-1 fields
[rfc2.txt]:                  are automatically added into the low order position of
[rfc2.txt]:                  the next higher field, so that in folding, one need
[rfc2.txt]:                  only add the [n] result fields to the carry from the
[rfc2.txt]:                  nth field, and then add in an appropiately sized carry
[rfc2.txt]:                  from that addition (and repeat the desired number of
[rfc2.txt]:                  times to achieve the result.
[rfc2.txt]:            3b1a3 A checksum computed in this manner has the advantage
[rfc2.txt]:            that the word lengths of different machines may each be used
[rfc2.txt]:               computing the checksum, and a suitable checksum field
[rfc2.txt]:               length is selected, the checksum technique for each of
[rfc2.txt]:               the machines will be relatively optimal.
[rfc2.txt]:         checksum may be got by shifting the checksum for each group,
[rfc2.txt]:         and adding it in (successively) to the checksum of the next
[rfc2.txt]:   sent over the control link.
[rfc2.txt]:            4a1c1 There is a strong possibility that the character
[rfc2.txt]:            translation may be done in the IMP.
[rfc2.txt]:            4a1c2 This needs to be explored further with BBN.
[rfc2.txt]:               4a1c3a Should the translation be done by table or
[rfc2.txt]:                  4a1c3a1 Initially it seems as though the best way to
[rfc2.txt]:            4a2b1 See remarks under the section on output translation
[rfc2.txt]:            4a2d1 If there has not been a RFNM since the last message
[rfc2.txt]:            transmitted out the link, wait for it.
[rfc2.txt]:      4b1 Maintain status of other HOSTs on network
[rfc2.txt]:         4b1a If an IMP is down, then his HOST is considered to be down.
[rfc2.txt]:      4b3 Answer status queries from other HOSTs.
[rfc2.txt]:      4b4 Inform other HOSTs as to status of primary and auxilliary
[rfc2.txt]:      4b5 Inform other HOSTs as to status of programs using primary and
[rfc2.txt]:      5a1 These require the HOST number as a parameter.
[rfc2.txt]:         5b1a requires the HOST number as a parameter
[rfc2.txt]:         file index. It is this number which is passed to all of the
[rfc2.txt]:         other Auxilliary routines as a parameter.
[rfc2.txt]:         5c1b The function of the monitor in this instance is to
[rfc2.txt]:            5c1c1 This means that the header and other control
[rfc2.txt]:            information must be in the buffer.
[rfc2.txt]:   6a The network will be initially checked out using the links in a
[rfc2.txt]:      6a2 Links will be transparent to the monitor, and controlled by
[rfc2.txt]:           [  into the online RFC archives by Robbie Bennet 10/1998  ]
[rfc20.txt]:   For concreteness, we suggest the use of standard 7-bit ASCII embedded
[rfc20.txt]:   in an 8 bit byte whose high order bit is always 0.  This leads to the
[rfc20.txt]:   standard code given on the attached page, copies from USAS X3, 4-
[rfc20.txt]:   Break characters will be defined by the receiving remote host, e.g.
[rfc20.txt]:   SRI uses "." (ASCII X'2E' or 2/14) as the end-of-line character,
[rfc20.txt]:   This coded character set is to be used for the general interchange of
[rfc20.txt]:   The standard 7-bit character representation, with b7 the high-order
[rfc20.txt]:   bit and b1 the low-order bit, is shown below:
[rfc20.txt]:   EXAMPLE: The bit representation for the character "K," positioned in
[rfc20.txt]:   The code table position for the character "K" may also be represented
[rfc20.txt]:   by the notation "column 4, row 11" or alternatively as "4/11."  The
[rfc20.txt]:   decimal equivalent of the binary number formed by bits b7, b6, and
[rfc20.txt]:   b5, collectively, forms the column number, and the decimal equivalent
[rfc20.txt]:   of the binary number formed by bits b4, b3, b2, and b1, collectively,
[rfc20.txt]:   forms the row number.
[rfc20.txt]:   The standard code may be identified by the use of the notation ASCII
[rfc20.txt]:   sas'-key) should ordinarily be taken to mean the code prescribed by
[rfc20.txt]:   the latest issue of the standard.  To explicitly designate a
[rfc20.txt]:   particular (perhaps prior) issue, the last two digits of the year of
[rfc20.txt]:   [1] In the strict sense, DEL is not a control character.  (See 5.2)
[rfc20.txt]:   2/8         (           Opening Parenthesis
[rfc20.txt]:   2/9         )           Closing Parenthesis
[rfc20.txt]:      2 The use of the symbols in 2/2, 2/7, 2/12, 5/14, /6/0, and 7/14
[rfc20.txt]:   without determining that there is agreement between sender and
[rfc20.txt]:      4 In applications where there is no requirement for the symbol #,
[rfc20.txt]:   the symbol (Pounds Sterling) may be used in position 2/3.
[rfc20.txt]:      (FE)  Format Effector: A functional character which controls the
[rfc20.txt]:   the beginning of a sequence of characters which constitute a
[rfc20.txt]:   referred to as the "heading."  An STX character has the effect of
[rfc20.txt]:   and entirely transmitted through to the ultimate destination.  Such a
[rfc20.txt]:   to indicate the conclusion of a transmission, which may have
[rfc20.txt]:      BEL (Bell): A character for use when there is a need to call for
[rfc20.txt]:      BS (Backspace): A format effector which controls the movement of
[rfc20.txt]:   the printing position one printing space backward on the same
[rfc20.txt]:      HT (Horizontal Tabulation): A format effector which controls the
[rfc20.txt]:   movement of the printing position to the next in a series of
[rfc20.txt]:   predetermined positions along the printing line.  (Applicable also to
[rfc20.txt]:   display devices and the skip function on punched cards.)
[rfc20.txt]:      LF (Line Feed): A format effector which controls the movement of
[rfc20.txt]:   the printing position to the next printing line.  (Applicable also to
[rfc20.txt]:   display devices.) Where appropriate, this character may have the
[rfc20.txt]:   meaning "New Line" (NL), a format effector which controls the
[rfc20.txt]:   movement of the printing point to the first printing position on the
[rfc20.txt]:      VT (Vertical Tabulation): A format effector which controls the
[rfc20.txt]:   movement of the printing position to the next in a series of
[rfc20.txt]:      FF (Form Feed): A format effector which controls the movement of
[rfc20.txt]:   the printing position to the first pre-determined printing line on
[rfc20.txt]:   the next form or page.  (Applicable also to display devices.)
[rfc20.txt]:      CR (Carriage Return): A format effector which controls the
[rfc20.txt]:   movement of the printing position to the first printing position on
[rfc20.txt]:   the same printing line.  (Applicable also to display devices.)
[rfc20.txt]:      SO (Shift Out): A control character indicating that the code
[rfc20.txt]:   combinations which follow shall be interpreted as outside of the
[rfc20.txt]:   character set of the standard code table until a Shift In character
[rfc20.txt]:      SI (Shift In): A control character indicating that the code
[rfc20.txt]:   combinations which follow shall be interpreted according to the
[rfc20.txt]:   will change the meaning of a limited number of contiguously following
[rfc20.txt]:      DC1, DC2, DC3, DC4 (Device Controls): Characters for the control
[rfc20.txt]:   off ancillary devices, DC4 is the preferred assignment.)
[rfc20.txt]:   transmitted by a receiver as a negative response to the sender.
[rfc20.txt]:   a synchronous transmission system in the absence of any other
[rfc20.txt]:   used to indicate the end of a block of data for communication
[rfc20.txt]:   purposes.  ETB is used for blocking data where the block structure is
[rfc20.txt]:   not necessarily related to the processing format.
[rfc20.txt]:      CAN (Cancel): A control character used to indicate that the data
[rfc20.txt]:      EM (End of Medium): A control character associated with the sent
[rfc20.txt]:   data which may be used to identify the physical end of the medium, or
[rfc20.txt]:   the end of the used, or wanted, portion of information recorded on a
[rfc20.txt]:(The position of this character does not necessarily correspond to the
[rfc20.txt]:   physical end of the medium.)
[rfc20.txt]:   interchange.  The Escape character itself is a prefix affecting the
[rfc20.txt]:   within data in optional fashion, except that their hierarchical
[rfc20.txt]:   relationship shall be: FS is the most inclusive, then GS, then RS,
[rfc20.txt]:   (In the strict sense, DEL is not a control character.)
[rfc20.txt]:   separate words.  It is also a format effector which controls the
[rfc20.txt]:   movement of the printing position, one printing position forward.
[rfc20.txt]:   6.1 This standard does not define the means by which the coded set is
[rfc20.txt]:   redundancy or define techniques for error control.  Further, this
[rfc20.txt]:   6.2 Deviations from the standard may create serious difficulties in
[rfc20.txt]:   of the parties involved.
[rfc20.txt]:   for collation, is defined by their binary values.
[rfc20.txt]:   6.4 No specific meaning is prescribed for any of the graphics in the
[rfc20.txt]:   code table except that which is understood by the users.
[rfc20.txt]:   Furthermore, this standard does not specify a type style for the
[rfc20.txt]:   printing or display of the various graphic characters.  In specific
[rfc20.txt]:   individual graphics to facilitate their use for specific purposes as,
[rfc20.txt]:   for example, to stylize the graphics in code positions 2/1 and 5/15
[rfc20.txt]:   the design and use of this code.
[rfc20.txt]:           [ into the online RFC archives by Robbie Bennet 9/99]
[rfc21.txt]:At UCLA on October 10, there was a network meeting attended by:
[rfc21.txt]:    and 63 active receive links at a time.  If the Host attempts to
[rfc21.txt]:    exist, a "Link Table Full" message will be sent from the IMP to
[rfc21.txt]:    the Host, and the message will be discarded."
[rfc21.txt]:       will have its entry automatically deleted by the IMP program."
[rfc21.txt]:[Cerf:  How about deleting only if the transmit link table is full?
[rfc21.txt]: Crocker:  No, because there is no other way for links to be deleted
[rfc21.txt]:           so they would always tend to accumulate.  Furthermore,
[rfc21.txt]:           the table at one site may be full while another site may
[rfc21.txt]:    reaches any Hosts since it will be discarded when it reaches the 
[rfc21.txt]:    top of the IMP-HOST queue in the destination Host's IMP.  The
[rfc21.txt]:    discussions with other nodes.  NWG/RFC 22 contains some of the
[rfc21.txt]:3.  George Gregg of UCSB will publish NWG/RFC 23 concerning the
[rfc22.txt]:   the meantime, it seems important to report a new control message
[rfc22.txt]:   the form:
[rfc22.txt]:   Presently, 9 control messages have been defined by UCLA; these are
[rfc22.txt]:   given in the table below along with their parameters.  The
[rfc22.txt]:   interpretation is given from the point of view of the transmitting
[rfc22.txt]:                                  number L.  This is called the CEASE
[rfc22.txt]:                                  the last message arrives over this
[rfc22.txt]:   Each control message is embedded in the appropriate message structure
[rfc22.txt]:      [ into the online RFC archives by Alison De La Cruz 12/00 ]
[rfc23.txt]:During the time that the control link is blocked awaiting RFNM, it is
[rfc23.txt]:will accumulate.  When the link is unblocked, these should all be sent
[rfc23.txt]:decode and take action on successive control messages until the control
[rfc24.txt]:The Network Working Group (NWG) is concerned with the HOST software,
[rfc24.txt]:the strategies for using the network, and initial experience with the
[rfc24.txt]:Documentation of the NWG's effort is through notes such as this.  Notes
[rfc24.txt]:to the HOST software or other aspect of the network.  Notes are
[rfc24.txt]:encouraged to be timely rather than polished.  Philosophical positions
[rfc24.txt]:without examples or other specifics, specific suggestions or
[rfc24.txt]:These standards (or lack of them) are stated explicitly for two reasons.
[rfc24.txt]:First, there is a tendency to view a written statement as ipso facto
[rfc24.txt]:authoritative, and we hope to promote the exchange and discussion of
[rfc24.txt]:considerably less than authoritative ideas.  Second, there is a natural
[rfc24.txt]:Every NWG note should bear the following information:
[rfc24.txt]:One copy only will be sent from the author's site to:
[rfc24.txt]:Below are the most current addresses I have.  Please correct as necessary:
[rfc27.txt]:The Network Working Group (NWG) is concerned with the HOST software,
[rfc27.txt]:the strategies for using the network, and initial experience with the
[rfc27.txt]:Documentation of the NWG's effort is through notes such as this.  Notes
[rfc27.txt]:to the HOST software or other aspect of the network.  Notes are
[rfc27.txt]:encouraged to be timely rather than polished.  Philosophical positions
[rfc27.txt]:without examples or other specifics, specific suggestions or
[rfc27.txt]:These standards (or lack of them) are stated explicitly for two
[rfc27.txt]:reasons.  First, there is a tendency to view a written statement as
[rfc27.txt]:ipso facto authoritative, and we hope to promote the exchange and
[rfc27.txt]:there is a natural hesitancy to publish something unpolished, and we
[rfc27.txt]:Every NWG note should bear the following information:
[rfc27.txt]:One copy only will be sent from the author's site to:
[rfc27.txt]:        9.  Thomas O'Sullivan, Raytheon
[rfc27.txt]:Below are the most current addressed I have.  Please correct as
[rfc27.txt]:        Thomas O'Sullivan               Raytheon
[rfc27.txt]:        Raytheon Company                (617) 899-8400
[rfc28.txt]:T. O'Sullivan, Raytheon
[rfc29.txt]:Round-trip message transit times typically should be at least on the
[rfc29.txt]:timing of internal events within the IMP, as for example, during tracing.
[rfc29.txt]:T. O'Sullivan, Raytheon
[rfc3.txt]:The Network Working Group (NWG) is concerned with the HOST software, the
[rfc3.txt]:strategies for using the network, and initial experiments with the network.
[rfc3.txt]:Documentation of the NWG's effort is through notes such as this.  Notes
[rfc3.txt]:the HOST software or other aspect of the network.  Notes are encouraged to
[rfc3.txt]:be timely rather than polished.  Philosophical positions without examples
[rfc3.txt]:or other specifics, specific suggestions or implementation techniques
[rfc3.txt]:These standards (or lack of them) are stated explicitly for two reasons.
[rfc3.txt]:First, there is a tendency to view a written statement as ipso facto 
[rfc3.txt]:authoritative, and we hope to promote the exchange and discussion of 
[rfc3.txt]:considerably less than authoritative ideas.  Second, there is a natural
[rfc3.txt]:Every NWG note should bear the following information:
[rfc3.txt]:One copy only will be sent from the author's site to"
[rfc3.txt]:Other notes planned are on
[rfc30.txt]:The Network Working Group (NWG) is concerned with the HOST software, the
[rfc30.txt]:strategies for using the network, and initial experience with the network.
[rfc30.txt]:Documentation of the NWG's effort is through notes such as this.  Notes
[rfc30.txt]:to the HOST software or other aspect of the network.  Notes are encouraged
[rfc30.txt]:to be timely rather than polished.  Philosophical positions without examples
[rfc30.txt]:or other specifics, specific suggestions or implementation techniques
[rfc30.txt]:These standards (or lack of them) are stated explicitly for two reasons.
[rfc30.txt]:First, there is a tendency to view a written statement as ipso facto
[rfc30.txt]:authoritative, and we hope to promote the exchange and discussion of
[rfc30.txt]:considerably less than authoritative ideas.  Second, there is a natural
[rfc30.txt]:Every NWG note should bear the following information:
[rfc30.txt]:One copy only will be sent from the author's site to:
[rfc30.txt]:       10.  Thomas O'Sullivan, Raytheon
[rfc30.txt]:Below are the most current addresses I have.  Please correct as necessary:
[rfc30.txt]:        Thomas O'Sullivan               Raytheon
[rfc30.txt]:        Raytheon Company
[rfc31.txt]:                         William R. Sutherland
[rfc31.txt]:   important.  However, the variety of installations working in the area
[rfc31.txt]:   probably precludes standardization of the content and form of inter-
[rfc31.txt]:     Considerable progress has been made at the low level of message
[rfc31.txt]:   handling protocol and one can expect the ASCII protocols to be used.
[rfc31.txt]:   The discussion which follows assumes that the mechanics of exchanging
[rfc31.txt]:   The topic of concern is how to describe the content and intent of a
[rfc31.txt]:   binary message body when the network header and trailer details have
[rfc31.txt]:     Most attempts at describing the content of binary messages
[rfc31.txt]:   jump immediately into a consideration of the bit codings to be used.
[rfc31.txt]:   Long, thin rectangles are drawn to represent the binary bit stream;
[rfc31.txt]:   the bit options for each box.  A better approach would be to provide
[rfc31.txt]:   one's understanding of the message content and the alternatives
[rfc31.txt]:   available in the message body.  When the basic form of the binary
[rfc31.txt]:   message body is clear, the coding details of the actual bit fields
[rfc31.txt]:   (BNF) then show how the characters can be concatenated and what
[rfc31.txt]:   descriptions require the additional capacity of defining various size
[rfc31.txt]:   fields in the message and the interpretation to be placed on the bits
[rfc31.txt]:   contained in the field.
[rfc31.txt]:   computer network.  From this standard, the new user can discover the
[rfc31.txt]:   kind and form of the binary data being exchanged over the network.
[rfc31.txt]:   Once this is known, the programs necessary for using the network
[rfc31.txt]:   can envision the promulgation of standards for newly developed binary
[rfc31.txt]:   formats via the exchange of ASCII text messages over the network
[rfc31.txt]:   itself instead of on paper through the mail.  Still farther into the
[rfc31.txt]:   future, the text of a binary format standard could be used as input
[rfc31.txt]:   programs for converting one binary format to another.  Right now,
[rfc31.txt]:   consisting of a consecutive number of bits in the message.  Binary
[rfc31.txt]:     1) Symbolic names are declared for all the different kinds of
[rfc31.txt]:        fields found in the binary format being defined.
[rfc31.txt]:   the contents of the field represent.  For example:
[rfc31.txt]:   single quotes followed by the field name.  A number consists of
[rfc31.txt]:   standard digits construed as binary if zeros and ones.  Other numbers
[rfc31.txt]:   Field values are integer numbers assigned such that the least
[rfc31.txt]:   significant bit is sent first.  Only that part of the number which
[rfc31.txt]:   fits the field is used.  Appropriate sign extension is needed for
[rfc31.txt]:   than the field.
[rfc31.txt]:   message part) by indicating how other fields can be combined and is
[rfc31.txt]:   field name separated (by <-) from the concatenation indications on
[rfc31.txt]:   the right.  Field names or equivalent names are concatenated by plus
[rfc31.txt]:   plus so that A + B/C means A followed by either B or C.  Alternatives
[rfc31.txt]:   must be distinguishable in their own right.
[rfc31.txt]:     Characterization statement parts can be grouped in the normal
[rfc31.txt]:   manner by parentheses.  (A + B)/C means either A followed by B or C.
[rfc31.txt]:     Repeated occurrences of a field may be indicated by following the
[rfc31.txt]:   variable within the right side of a characterization statement.  This
[rfc31.txt]:   variable can then be used as a repetition indicator.  Example:
[rfc31.txt]:   then exactly that number of CPAIRS.  All variables are global in
[rfc31.txt]:   occur depending on the contents of some other previous field.  This
[rfc31.txt]:   situation is indicated by assigning a label to the determining field.
[rfc31.txt]:   The conditional occurrence is then indicated by enclosing a condition
[rfc31.txt]:   expression and the optional field description in brackets ([ and ]).
[rfc31.txt]:     c) Field PPAIRS if the first field (V) was C1; otherwise, this
[rfc31.txt]:   third field is not present in the message.
[rfc31.txt]:     Alternatives selected by the contents of some previous field rather
[rfc31.txt]:   than by the contents of the alternative field itself are indicated by
[rfc31.txt]:   an extension of the conditional field notation.  For example:
[rfc31.txt]:   The determining field occurs at the beginning of the conditional
[rfc31.txt]:   alternative and each alternative then includes its value for the
[rfc31.txt]:   determining field and the alternative field then present.
[rfc31.txt]:   This size declaration should appear at the end of the
[rfc31.txt]:   message description; thus, forcing the reader to postpone an early
[rfc31.txt]:   [ into the online RFC archives by Dave Bachmann 1/98 ]
[rfc32.txt]:The addition of a clock in one or more of the network HOST's seems to be
[rfc32.txt]:very desireable since it (or they) would allow user-oriented message
[rfc32.txt]:include any internal HOST delays, and these delays may be an appreciable
[rfc32.txt]:portion of the total delay encountered by a HOST-to-HOST message
[rfc32.txt]:utilizing such a clock.  Such usage would require a clock at both the
[rfc32.txt]:source and the destination of the message, although such clocks would
[rfc32.txt]:not have to be particularly accurate nor synchronized.  Other tests,
[rfc32.txt]:such as the absolute overall message delay from HOST A to HOST B would
[rfc32.txt]:require synchronization of the two clocks.
[rfc32.txt]:A reasonable specification for the SRI real-time clock would seem to
[rfc32.txt]:A crystal controlled clock should easily meet these requirements at a
[rfc32.txt]:The choice of the mechanism by which the HOST can read the clock appears
[rfc32.txt]:to be of concern also.  The 1 msec. resolution may require that the
[rfc32.txt]:incremented at each clock pulse), and therefore the clock may require
[rfc32.txt]:some rather compli- cated interface circuitry.
[rfc32.txt]:At UCLA, we presently have two clocks on the Sigma 7, and one of these
[rfc32.txt]:internal HOST measurements.  However, it does not have the long term
[rfc32.txt]:accuracy for the absolute measurements mentioned above.
[rfc32.txt]:         [ into the online RFC archives by Richard Ames 1/98 ]
[rfc33.txt]:   Attached is a copy of the paper to be presented at the SJCC on the
[rfc33.txt]:   HOST-HOST Protocol.  It indicates many changes from the old protocol
[rfc33.txt]:   in NWG/RFC 11; these changes resulted from the network meeting on
[rfc33.txt]:   information to write a NCP, and I will send out another memo or so
[rfc33.txt]:   shortly.  Responses to this memo are solicited, either as NWG/RFC's
[rfc33.txt]:                           in the ARPA Network*
[rfc33.txt]:   *This research was sponsored by the Advanced Research Projects
[rfc33.txt]:   (hereafter referred to as the "ARPA network") is one of the most
[rfc33.txt]:   machines and operating systems involved in the network vary widely.
[rfc33.txt]:   For example, the computers at the first four sites are an XDS 940
[rfc33.txt]:   commonality among the network membership is the use of highly
[rfc33.txt]:   interactive time-sharing systems; but, of course, these are all
[rfc33.txt]:   different in external appearance and implementation.  Furthermore, no
[rfc33.txt]:   one node is in control of the network.  This has insured reliability
[rfc33.txt]:   but complicates the software.
[rfc33.txt]:   Of the networks which have reached the operational phase and been
[rfc33.txt]:   reported in the literature, none have involved the variety of
[rfc33.txt]:   computers and operating systems found in the ARPA network.  For
[rfc33.txt]:   example, the Carnegie-Mellon, Princeton, IBM network consists of
[rfc33.txt]:   in the early 1960's.  Therefore, the implementers of the present
[rfc33.txt]:   However, early time-sharing studies at the University of California
[rfc33.txt]:   the design of the network.  In some sense, the ARPA network of time-
[rfc33.txt]:   individual computers insert messages destined for another (or the
[rfc33.txt]:   such messages and the operation of the network was specified by the
[rfc33.txt]:   network contractor (BB&N) and it became the responsibility of
[rfc33.txt]:   representatives of the various computer sites to impose such
[rfc33.txt]:   details the decisions that have been made and the considerations
[rfc33.txt]:   behind these decisions.
[rfc33.txt]:   and W. Duvall of SRI participated in the early design effort of the
[rfc33.txt]:   protocol and in the discussions of NIL.  G. Deloche of Thompson-CSF
[rfc33.txt]:   participated in the design effort while he was at UCLA and provided
[rfc33.txt]:   Lincoln Laboratory reviewed the early design and NIL.  W. Crowther of
[rfc33.txt]:   Bolt, Beranek and Newman, contributed the idea of a virtual net.  The
[rfc33.txt]:   delivering the network.
[rfc33.txt]:   We have found that, in the process of connecting machines and
[rfc33.txt]:   operating systems together, a great deal of rapport has been
[rfc33.txt]:   established between personnel at the various network node sites.  The
[rfc33.txt]:   involved, and we regard the human interaction as a valuable by-
[rfc33.txt]:   product of the main effect.
[rfc33.txt]:      A HOST is a computer system which is a part of the network,
[rfc33.txt]:      site, and allows HOSTs access into the network.  The configuration
[rfc33.txt]:      of the initial four-HOST network is given in figure 1.  The IMPs
[rfc33.txt]:      paper in these proceedings covers the IMPs in some detail. [3]
[rfc33.txt]:   an IMP by a HOST for transmission to another HOST.  The first 32 bits
[rfc33.txt]:   of the message are the leader.  The leader contains the following
[rfc33.txt]:   When a message is transmitted from a HOST to its IMP, the HOST field
[rfc33.txt]:   of the leader names the receiving HOST.  When the message arrives at
[rfc33.txt]:   the receiving HOST, the HOST field names the sending HOST.
[rfc33.txt]:   to a foreign HOST.  The other message type of interest is a RFNM
[rfc33.txt]:   The flag field of the leader controls special cases not of concern
[rfc33.txt]:   between the sending HOST and the receiving HOST the message will be
[rfc33.txt]:   sent.  Each link is unidirectional and is controlled by the network
[rfc33.txt]:   sent a message to a receiving HOST over a particular link, the
[rfc33.txt]:   sending HOST is prohibited from sending another message over that
[rfc33.txt]:   same link until the sending HOST receives a RFMN.  The RFNM is
[rfc33.txt]:   generated by the IMP connected to the receiving HOST, and the RFNM is
[rfc33.txt]:   sent back to the sending HOST after the message has entered the
[rfc33.txt]:   receiving HOST.  It is important to remember that there are 356 links
[rfc33.txt]:   in each direction and that no relationship among these is imposed by
[rfc33.txt]:   the network.
[rfc33.txt]:   The purpose of the link and RFMN mechanism is to prohibit individual
[rfc33.txt]:   the assumption that a user does not use multiple links to achieve a
[rfc33.txt]:   wide band, and to a large extent the HOST-HOST protocol cooperates
[rfc33.txt]:   that the network's load comes from some users transmitting sequences
[rfc33.txt]:   of messages rather than many users transmitting single messages
[rfc33.txt]:   In order to delimit the length of the message, and to make it easier
[rfc33.txt]:   for HOSTs of differing word lengths to communicate, the following
[rfc33.txt]:   output, it creates a 32-bit leader.  Following the leader is a binary
[rfc33.txt]:   followed by one.  Marking makes is possible for the sending HOST to
[rfc33.txt]:   synchronize the beginning of the text message with its word
[rfc33.txt]:   boundaries.  When the last bit of a message has entered an IMP, the
[rfc33.txt]:   hardware interface between the IMP and HOST appends a one followed by
[rfc33.txt]:   enough zeros to make the message length a multiple of 16 bits.  These
[rfc33.txt]:   appended bits are called padding.  Except for the marking and
[rfc33.txt]:   padding, no limitations are placed on the text of a message.  Figure
[rfc33.txt]:   The computers participating in the network are alike in two important
[rfc33.txt]:   respects: each supports research independent of the network, and each
[rfc33.txt]:   is under the discipline of a time-sharing system.  These facts
[rfc33.txt]:   contributed to the following design philosophy.
[rfc33.txt]:   First, because the computers in the network have independent purposes
[rfc33.txt]:   the various computers.  Since all of the time-sharing supervisors
[rfc33.txt]:   mechanisms, we arranged matters so that these mechanisms would
[rfc33.txt]:   control the load due to the network in the same way that they control
[rfc33.txt]:   Second, because the computers are all operated under time-sharing
[rfc33.txt]:   imperative to provide the widest latitude in using the network.
[rfc33.txt]:   Fourth, again because the network is used by experienced programmers,
[rfc33.txt]:   it was felt necessary to leave the design open-ended.  We expect that
[rfc33.txt]:   we felt constrained not to impose them arbitrarily.
[rfc33.txt]:   cases, feasible, the software interface to the network should require
[rfc33.txt]:   minimal surgery on the HOST operating system.
[rfc33.txt]:   Finally, we except the assumption stated above that network use
[rfc33.txt]:   These considerations led to the notions of connections, a Network
[rfc33.txt]:   processes so that output from one process is input to the other.
[rfc33.txt]:   Processes within a HOST communicate with the network through a
[rfc33.txt]:   Network Control Program (NCP).  In most HOSTs, the NCP will be a part
[rfc33.txt]:   of the executive, so that processes will use system calls to
[rfc33.txt]:   communicate with it.  The primary function of the NCP is to establish
[rfc33.txt]:   with a NCP in another HOST.  To this end, a particular link between
[rfc33.txt]:   each pair of HOSTs has been designated as the control link.  Messages
[rfc33.txt]:   received over the control link are always interpreted by the NCP as a
[rfc33.txt]:   sequence of one or more control commands.  As an example, one of the
[rfc33.txt]:   connection, while another kind carries notification that a connection
[rfc33.txt]:   has been terminated.  A partial sketch of the syntax and semantics of
[rfc33.txt]:   control commands is given in the next section.
[rfc33.txt]:   HOST has some internal naming scheme, but these various schemes often
[rfc33.txt]:   created with a separate portion of the name space given to each HOST.
[rfc33.txt]:   The elements of the name space are called sockets.  A socket forms
[rfc33.txt]:   pair of sockets.  A socket is specified by the concatenation of three
[rfc33.txt]:   Each HOST is assigned all sockets in the name space which have field
[rfc33.txt]:   (b) equal to the HOST's own identification.
[rfc33.txt]:   A socket is either a receive socket or a send socket, and is so
[rfc33.txt]:   marked by the lower-order bit of the AEN (0 = receive, 1 = send).
[rfc33.txt]:   The other seven bits of the AEN simply provide a sizable population
[rfc33.txt]:   "another eight-bit number")
[rfc33.txt]:   him throughout the network.  Generally this will be the 8-bit HOST
[rfc33.txt]:   HOST.  This 24-bit user number is then used in the following manner.
[rfc33.txt]:   Thereafter, each process the user creates is tagged with his user
[rfc33.txt]:   number.  When the user signs onto a foreign HOST via the network, his
[rfc33.txt]:   The foreign HOST obtains the user number either by consulting a table
[rfc33.txt]:   at login time, as the home HOST does, or by noticing the
[rfc33.txt]:   identification of the caller.  The effect of propagating the user's
[rfc33.txt]:   his processes with those in other virtual nets.
[rfc33.txt]:   (see Figure 4).  For each user number at each HOST, there are 128
[rfc33.txt]:   send sockets and 128 receive sockets.  A process may request from the
[rfc33.txt]:   local NCP the use of any one of the sockets with the same user
[rfc33.txt]:   number; the request is granted if the socket is not otherwise in use.
[rfc33.txt]:   cannot already be in use unless it is by some other process within
[rfc33.txt]:   the same virtual net, and such a process is controlled by the same
[rfc33.txt]:   An unusual aspect of the HOST-HOST protocol is that a process may
[rfc33.txt]:   switch its end of a connection from one socket to another.  The new
[rfc33.txt]:   socket may be in any virtual net and at any HOST, and the process may
[rfc33.txt]:   initiate a switch either at the time the connection is being
[rfc33.txt]:   quite complex implementation, and are not germane to the rest of this
[rfc33.txt]:   for another while establishing a connection.  The new socket must
[rfc33.txt]:   have the same user number and HOST number, and the connection is
[rfc33.txt]:   still established to the same process.  This form of switching is
[rfc33.txt]:   thus only a way of relabelling a socket, for no charge in the routing
[rfc33.txt]:   of messages takes place.  In the next section we document the system
[rfc33.txt]:   calls and control commands; in the section after next, we consider
[rfc33.txt]:   Here we sketch the mechanisms of establishing, switching and breaking
[rfc33.txt]:   a connection.  As noted above, the NCP interacts with user processes
[rfc33.txt]:   via system calls and with other NCPs via control commands.  We
[rfc33.txt]:   therefore begin with a partial description of system calls and
[rfc33.txt]:   System calls will vary from one operating system to another, so the
[rfc33.txt]:   connected, transmits information in only one direction.  We further
[rfc33.txt]:   assume that the process is blocked (dismissed, slept) while
[rfc33.txt]:   transmission proceeds.  The following is the list of system calls:
[rfc33.txt]:      where <port> is part of the process issuing the Init
[rfc33.txt]:            The first AEN is used to initiate the connection; the second
[rfc33.txt]:            is used while the connection exists.
[rfc33.txt]:            <foreign socket> is the 40-bit socket name of the distant
[rfc33.txt]:            end of the connection.
[rfc33.txt]:            these must be the complement of the lower-order bit of
[rfc33.txt]:            The NCP concatenates <AEN 1> and <AEN 2> each with the user
[rfc33.txt]:            number of the process and the HOST number to form 40-bit
[rfc33.txt]:            sockets.  It then sends a Request for Connection (RFC)
[rfc33.txt]:            control command to the distant NCP.  When the distant NCP
[rfc33.txt]:            responds positively, the connection is established and the
[rfc33.txt]:            process is unblocked.  If the distant NCP responds
[rfc33.txt]:            negatively, the local NCP unblocks the requesting process,
[rfc33.txt]:            but informs it that the system call has failed.
[rfc33.txt]:      where <port> and <AEN 1> are as above.  The NCP retains the ports
[rfc33.txt]:            and <AEN 1> and blocks the process.  When an RFC control
[rfc33.txt]:            command arrives naming the local socket, the process is
[rfc33.txt]:            After a Listen has been satisfied, the process may either
[rfc33.txt]:            refuse the call or accept it and switch it to another
[rfc33.txt]:            socket.  To accept the call, the process issues the Accept
[rfc33.txt]:            system call.  The NCP then sends back an RFC control
[rfc33.txt]:            break the connection.  The Close is also issued after a
[rfc33.txt]:            stored at <addr>.  The length of the message is stored
[rfc33.txt]:   This command is sent because a process has executed either an Init
[rfc33.txt]:   system call or an Accept system call.  A link is assigned by the
[rfc33.txt]:   There is distinct advantage in using the same commands both to
[rfc33.txt]:   initiate a connection (Init) and to accept a call (Accept).  If the
[rfc33.txt]:   responding command were different from the initiating command, then
[rfc33.txt]:   two processes could call each other and become blocked waiting for
[rfc33.txt]:   each other to respond.  With this scheme, no deadlock occurs and it
[rfc33.txt]:   When the receiving process does not consume its input as fast as it
[rfc33.txt]:   arrives, the buffer space in the receiving HOST is used to queue the
[rfc33.txt]:   the receiving HOST may need to inhibit the sending HOST from sending
[rfc33.txt]:   any more messages over the offending connection.  When the sending
[rfc33.txt]:   HOST receives this command, it may block the process generating the
[rfc33.txt]:   This command is also sent from the receiving HOST to the sending HOST
[rfc33.txt]:   We assume that within each HOST there is always a process in
[rfc33.txt]:   execution which listens to login requests.  We call this process the
[rfc33.txt]:   0.  Upon receiving a call, the logger switches it to a higher (even)
[rfc33.txt]:   numbered sockets, and returns a call to the socket numbered one less
[rfc33.txt]:   than the send socket originally calling.  In this fashion, the logger
[rfc33.txt]:   this program wants to start a process at SRI.  No process except the
[rfc33.txt]:   His process is blocked, and the NCP at UCLA sends
[rfc33.txt]:   The logger then executes
[rfc33.txt]:   In response to the Accept, the SRI NCP sends
[rfc33.txt]:   where the link has been chosen from the set of available links.  The
[rfc33.txt]:   which causes the NCP to send
[rfc33.txt]:   The process at UCLA is unblocked and notified of the successful Init.
[rfc33.txt]:   Because SRI logger always initiates a connection to the AEN one less
[rfc33.txt]:   than it has just been connected to, the UCLA process then executes
[rfc33.txt]:   When these transactions are complete, the UCLA process is doubly
[rfc33.txt]:   connected to the logger at SRI.  The logger will then interrogate the
[rfc33.txt]:   connections wil be switched to the new process.  In this case,
[rfc33.txt]:   switching the connections to the new process corresponds to "passing
[rfc33.txt]:   the console down" in many time-sharing systems.
[rfc33.txt]:   At the user level, subroutines which manage data buffer and format
[rfc33.txt]:   input designed for other HOSTs are provided.  It is not mandatory
[rfc33.txt]:   that the user use such subroutines, since the user has access to the
[rfc33.txt]:   subsystem program at each HOST which makes the network immediately
[rfc33.txt]:   subsystem is TELNET, which will allow users at the University of Utah
[rfc33.txt]:   will be developed in time, but this basic one will render the early
[rfc33.txt]:   A user at the University of Utah (UTAH) is sitting at a teletype
[rfc33.txt]:   dialed into the University's PDP-10/50 time-sharing system.  He
[rfc33.txt]:   wishes to operate the Conversational Algebraic Language (CAL)
[rfc33.txt]:   subsystem on the XDS-940 at Stanford Research Institute (SRI) in
[rfc33.txt]:      (ii)     The PDP-10 run command starts up the TELNET subsystem at
[rfc33.txt]:               the user's HOST.
[rfc33.txt]:               message following the break to be interpreted locally
[rfc33.txt]:               rather than being sent on the foreign HOST.
[rfc33.txt]:      (iv)     The TELNET subsystem will make the appropriate system
[rfc33.txt]:               calls to establish a pair of connections to the SRI
[rfc33.txt]:               accepts another foreign user.
[rfc33.txt]:   The UTAH user is now in the pre-logged-in state at SRI.  This is
[rfc33.txt]:   analogous to the standard teletype user's state after dialing into a
[rfc33.txt]:               Characters typed on the user's teletype are transmitted
[rfc33.txt]:               unaltered through the PDP-10 (user HOST) and on to the
[rfc33.txt]:               940.  Full duplex operation is allowed for by the PDP-10,
[rfc33.txt]:   At this point, the user wishes to load a local CAL file into the 940
[rfc33.txt]:   CAL subsystem, from the file system on his local PDP-10.
[rfc33.txt]:      (ix)     Finally, the user types the break character (#) followed
[rfc33.txt]:               the desired file to SRI from Utah on the connection just
[rfc33.txt]:   shell program built over the network system calls.  It effectively
[rfc33.txt]:   established a shunt in the user HOST between the remote user and a
[rfc33.txt]:   Given the basic system primitives, the TELNET subsystem at the user
[rfc33.txt]:   HOST and a manual for the serving HOST, the network can be profitably
[rfc33.txt]:   is required between the user and a particular subsystem in a foreign
[rfc33.txt]:   a distant user to make use of the more sophisticated subsystems
[rfc33.txt]:   offered.  While these difficulties are especially severe in the area
[rfc33.txt]:   consoles connected by telephone, and then this subsystem becomes
[rfc33.txt]:   available to network users.  This subsystem might have the following
[rfc33.txt]:         echoed as the character is typed.
[rfc33.txt]:      3. <- causes deletion of the immediately preceding character, and
[rfc33.txt]:   If each character typed is sent in its own message, then the
[rfc33.txt]:   cause nine messages in each direction.  Furthermore, each character
[rfc33.txt]:   is handled by a user level program in the local HOST before being
[rfc33.txt]:   sent to the foreign HOST.
[rfc33.txt]:   only complete lines to the foreign HOST.  If the foreign HOST program
[rfc33.txt]:   could not be modified so as to not generate echoes, then the local
[rfc33.txt]:   program could not only echo properly, it could also throw away the
[rfc33.txt]:   later echoes from the foreign HOST.  However, the problem is not any
[rfc33.txt]:   particular interaction scheme; the problem is that we expect many of
[rfc33.txt]:   these kinds of schemes to occur.  We have not found any general
[rfc33.txt]:   solutions to these problems, but some observations and conjectures
[rfc33.txt]:   may lead the way.
[rfc33.txt]:   reasonable to treat a model 37 teletype as the equivalent of an IBM
[rfc33.txt]:   and most refresh display scopes will form another.  Furthermore, a
[rfc33.txt]:   those in another, but not vice versa.  We can imagine that any scope
[rfc33.txt]:   might be an adequate substitute for a teletype, but hardly the
[rfc33.txt]:   semantics appropriate to each class.  Each site could then write
[rfc33.txt]:   interface programs for its consoles to make them look like network
[rfc33.txt]:   Another observation is that a user evaluates an interactive system by
[rfc33.txt]:   comparing the speed of the system's responses with his own
[rfc33.txt]:   request, so the response should be immediate; at other times he feels
[rfc33.txt]:   he has made a substantial request, and is therefore willing to wait
[rfc33.txt]:   for the response.  Some interactive subsystems are especially
[rfc33.txt]:   the responses to the user's expectations.  In the network, however, a
[rfc33.txt]:   foreign subsystem, and we may expect the response time for minor
[rfc33.txt]:   the interaction is fairly independent of the portion of the subsystem
[rfc33.txt]:   which does the heavy computing or I/O.  In such a case, it may be
[rfc33.txt]:   would be a "front end" which formats output to the user, accepts his
[rfc33.txt]:   In the example above, the program to accumulate a line and generate
[rfc33.txt]:   echoes would be the front end of some subsystem.  We now take notice
[rfc33.txt]:   of the fact that the local HOSTs have substantial computational
[rfc33.txt]:   power, but our current designs make use of the local HOST only as a
[rfc33.txt]:   data concentrator.  This is somewhat ironic, for the local HOST is
[rfc33.txt]:   performance because of the delays it introduces.
[rfc33.txt]:   These arguments have led us to consider the possibility of a Network
[rfc33.txt]:   writing the front end of interactive subsystems.  This language would
[rfc33.txt]:   have the feature that subprograms communicate through network-like
[rfc33.txt]:   connections.  The strategy is then to transport the source code for
[rfc33.txt]:   the front end of a subsystem to the local HOST, where it would be
[rfc33.txt]:   least the following semantic properties not generally found in other
[rfc33.txt]:         to accurately model the possible concurrencies.
[rfc33.txt]:         a program in between two other programs.  To achieve this, the
[rfc33.txt]:         would not be implicit in the source code.
[rfc33.txt]:         that one device may be substituted for another.  The
[rfc33.txt]:         then these structures must be easily implementable in NIL.
[rfc33.txt]:   is false, then NIL will not be useful; otherwise it seems worth
[rfc33.txt]:   pursuing.  Testing of this conjecture and further development of NIL
[rfc33.txt]:   of particular concern for the HOST organizations.  Considering the
[rfc33.txt]:   diversity of HOST computers to which a standard IMP must connect, the
[rfc33.txt]:   passed back and forth between the IMP and HOST programs.  Special
[rfc33.txt]:   normal data.  Messages waiting in queues in either machine are sent
[rfc33.txt]:   at the pleasure of the machine in which they reside with no concern
[rfc33.txt]:   for the needs of the other computer.
[rfc33.txt]:   The effect of the present software interface is the needless
[rfc33.txt]:   rebuffering of all messages in the HOST in addition to the buffering
[rfc33.txt]:   in the IMP.  The messages have no particular order other than arrival
[rfc33.txt]:   times at the IMP.  The Network Control Program at one HOST (e.g.,
[rfc33.txt]:   UTAH) needs waiting RFNM's before all other messages.  At another
[rfc33.txt]:   site (e.g., SRI), the NCP could benefit by receiving messages for the
[rfc33.txt]:   What is needed is coding representing the specific needs of the HOST
[rfc33.txt]:   on both sides of the interface to make intelligent decisions about
[rfc33.txt]:   what to transmit next over the channel.  With the present software
[rfc33.txt]:   interface, the channel in one direction once committed to a
[rfc33.txt]:   particular message is then locked up for up to 80 milliseconds!  This
[rfc33.txt]:   duplex, character by character, interactions over the net.  At the
[rfc33.txt]:   very least, the IMP/HOST protocol should be expended to permit each
[rfc33.txt]:   side to assist the other in scheduling messages over the channels.
[rfc33.txt]:   At this time (February 1970) the initial network of four sites is
[rfc33.txt]:   months.  Programmers at UCLA have signed in as users of the SRI 940.
[rfc33.txt]:   More significantly, one of the authors (S. Carr) living in Palo Alto
[rfc33.txt]:   uses the Salt Lake PDP-10 on a daily basis by first connecting to
[rfc33.txt]:   Work on the ARPA network has generated new areas of interest.  NIL is
[rfc33.txt]:   one example, and interprocess communication is another.  Interprocess
[rfc33.txt]:   communication over the network is a subcase of general interprocess
[rfc33.txt]:   connections seems to be new, and we wonder whether this mechanism is
[rfc33.txt]:   useful even when the processes are within the same computer.
[rfc33.txt]:         Proceedings of the 24th National Conference
[rfc33.txt]:         "The interface message processors for the ARPA network"
[rfc33.txt]:             Underlined characters are those types by the user.
[rfc33.txt]:                  by the interface
[rfc33.txt]:          [ into the online RFC archives by Lorrie Shiota 08/00]
[rfc34.txt]:The ARC clock system provides a time reference that is written into the
[rfc34.txt]:core memory of the XDS 940 Computer. There are two types of time
[rfc34.txt]:The absolute time is written into two adjacent words of core with the
[rfc34.txt]:      Bits 0 thru 7 contain the month code in straight binary with a
[rfc34.txt]:      Bits 8 thru 15 contain the day code in straight binary with a
[rfc34.txt]:      Bits 16 thru 23 contain the year code in straight binary with
[rfc34.txt]:      Bits 00 thru 7 contain the hour code written in straight binary
[rfc34.txt]:      Bits 8 thru 15 contain the minute code written in straight binary
[rfc34.txt]:      Bits 16 thru 23 contain the second code written in straight binary
[rfc34.txt]:These 2 words are written once each second.  It is anticipated that the
[rfc34.txt]:accuracy of the initial setting will be on the order of 1 second, as
[rfc34.txt]:referred to WWV, and that the oscillator drift rate will not account for
[rfc34.txt]:maintain the accuracy of the system.  Because of variable delays in time
[rfc34.txt]:required to obtain access to the 940 core memory, it is anticipated that
[rfc34.txt]:the short-term accuracy will be on the order of 10 to 20 microseconds.
[rfc34.txt]:simply the contents of a 24 bit binary accumulator.  The rate at which
[rfc34.txt]:the accumulator is updated can be chosen to be either once very 100
[rfc34.txt]:micro seconds or once every millisecond.  In either case the core
[rfc34.txt]:RFC 34              Prelimary Notes on the ARC Clock       February 1970
[rfc34.txt]:location is written each time the accumulator is updated.  As above the
[rfc34.txt]:short-term accuracy will be about 10 to 20 microseconds and the long-
[rfc34.txt]:term accuracy will be the equivalent of one second every 250 days.
[rfc34.txt]:       [ into the online RFC archives by Katsunori Tanaka 1/98 ]
[rfc35.txt]:     I expect to have the details of the new network protocol as
[rfc35.txt]:wise to leave the 18th open in case discussion continues.
[rfc35.txt]:     The subject of the meeting will be a detailed presentation of the
[rfc35.txt]:discovered.  Documentation will be available at the meeting and if not
[rfc35.txt]:obsoleted by the meeting, will be sent out as NWG/RFC on March 20.
[rfc35.txt]:       [ into the online RFC archives by Jochen Friedrich 4/97 ]
[rfc36.txt]:   partly because of the complexity of reconnection and partly because I
[rfc36.txt]:   don't have enough experience with the protocol to present these
[rfc36.txt]:   Connection establishment works essentially the same as in NWG/RFC
[rfc36.txt]:   2.  Concurrently with the above, process PB in host B grabs socket SB
[rfc36.txt]:   3.  In response to process PA's request, the network control program
[rfc36.txt]:       to host A.  No ordering is implied: NCPB may send the command to
[rfc36.txt]:       NCPA before or after receiving the command from NCPA.
[rfc36.txt]:   4.  NCPA and NCPB are both aware the connection is established when
[rfc36.txt]:       each has received a RFC command and each has received the RFNM
[rfc36.txt]:       for the one it has sent.  They then notify processes PA and PB,
[rfc36.txt]:       respectively, that the connection is established.
[rfc36.txt]:   One of the rules adhered to is that either SA is a send socket and SB
[rfc36.txt]:   processes it is necessary for the receiving process to be able to
[rfc36.txt]:   stop the flow(*).  Flow control is integrated into the network RFNM
[rfc36.txt]:   particular link, the host sends a special message to its IMP which
[rfc36.txt]:   causes the next RFNM on that link to be modified.  The sending host
[rfc36.txt]:   When the receiving host is ready to receive again, it sends a command
[rfc36.txt]:   (RSM) telling the sending host to resume sending.
[rfc36.txt]:   both) ends of a connection from one socket to another.  Depending
[rfc36.txt]:   upon the restrictions placed upon the switching process, it may be
[rfc36.txt]:   the majority of cases, this scheme is much more expensive than it
[rfc36.txt]:   needs to be; however, the following virtues are claimed:
[rfc36.txt]:      2. Reconnection introduces no overhead in the processing of
[rfc36.txt]:         messages sent over a connection i.e., the whole cost is borne
[rfc36.txt]:         in processing the protocol.
[rfc36.txt]:   my way of thinking, and I have based the protocol design on the
[rfc36.txt]:   assumption that only a small buffer is provided on the receive end of
[rfc36.txt]:   whether a socket is engaged in a connection, and if so, what state
[rfc36.txt]:   the connection is in.  Entries are keyed by local socket, but other
[rfc36.txt]:   tables have pointers into this table also.  (See the Process Table,
[rfc36.txt]:   Each entry contains the following information:
[rfc36.txt]:   The link is an 8 bit number and is the link over which data is sent
[rfc36.txt]:   from the sender to the receiver.  A socket is a receive socket iff
[rfc36.txt]:   Connection state refers to whether a connection is open or not, etc.
[rfc36.txt]:   A pointer to the user's process is necessary if the process has
[rfc36.txt]:   If reconnection is in progress, it is necessary to keep track of the
[rfc36.txt]:   sequence of events.  A socket engaged in reconnection is either an
[rfc36.txt]:   end or a middle.  If it's a middle, it is necessary to store the
[rfc36.txt]:   eight bit name of the other middle attached to the same process, and
[rfc36.txt]:   Finally, if RFC's are received either when the socket is busy or when
[rfc36.txt]:   no process has engaged it, the RFC's are stacked first-in-first-out
[rfc36.txt]:   on a queue for the named local socket.
[rfc36.txt]:            <my socket> is a 32 bit socket number local to the
[rfc36.txt]:            <your socket> is a 32 bit socket number local to the
[rfc36.txt]:             two hosts have exchanged  RFC  commands with the same
[rfc36.txt]:             arguments (reversed), the connection is established.
[rfc36.txt]:             Links are assigned by the receiver.
[rfc36.txt]:            <my socket> and <your socket> are the same as for <RFC>
[rfc36.txt]:             also be used to abort the establishment of a connection
[rfc36.txt]:             connection between the named sockets was established,
[rfc36.txt]:             or was in the process of being established.  In this
[rfc36.txt]:             event, the <CLS> should be discarded.
[rfc36.txt]:   Purpose:  This command is sent by a receiving host to cause the
[rfc36.txt]:             sending host to resume transmission on the named link.
[rfc36.txt]:             generated by the receiving IMP upon request by its
[rfc36.txt]:             that it has stopped sending over the named link.
[rfc36.txt]:            to the sender
[rfc36.txt]:            local to the receiver
[rfc36.txt]:            A connection should be established between them.
[rfc36.txt]:            <asker> is a 40 bit socket number of the same type as
[rfc36.txt]:             one of its receive sockets to one of its send sockets, the
[rfc36.txt]:             Upon receiving an <FND> command, the NCP checks its <your
[rfc36.txt]:             reconnection, the command is passed on with a new <my
[rfc36.txt]:             on, the <asker> is compared with the new <my socket>.  If
[rfc36.txt]:             they are equal, a loop has been detected and both sockets
[rfc36.txt]:             marked as the end of a chain of reconnections and an <END>
[rfc36.txt]:             If the connection named is not in progress, a <CLS> is sent
[rfc36.txt]:             back and the <FND> is discarded.
[rfc36.txt]:   Purpose:  This command indicates which socket is at the end of a
[rfc36.txt]:             socket> and passed back to the other terminal socket
[rfc36.txt]:             via all the intermediate sockets.  If <end socket> is a
[rfc36.txt]:             send socket, <link> refers to a connection with the
[rfc36.txt]:             send socket in the sending host and the receive socket
[rfc36.txt]:             in the receiving host.  If <end socket> is a receive
[rfc36.txt]:             socket, <link> refers to a connection with the send
[rfc36.txt]:             socket in the receiving host and the receive socket in
[rfc36.txt]:             the sending hose.  ("sending" end "receiving" refer to
[rfc36.txt]:             the transmission of this control command.)
[rfc36.txt]:             a receive socket to a send socket after the receive
[rfc36.txt]:           [ into the online RFC archives by Marc Blanchett 3/00 ]
[rfc37.txt]:  modification of the protocol in NWG/RFC #33; the modifications are
[rfc37.txt]:  sketchily documented in NWG/RFC #36.  The main modification is the
[rfc37.txt]:  connections is quite different from the previous protocol as
[rfc37.txt]:  out of the network meeting on December 8, 1969, at Utah, at which
[rfc37.txt]:  time the limitations of a log-in requirement and the inability to
[rfc37.txt]:  the primary reason for the recent meeting was to sample opinion on
[rfc37.txt]:  the new protocol.
[rfc37.txt]:  Recollections may vary, but it is my opinion that the protocol was
[rfc37.txt]:  widely accepted and that the criticism and discussion fell into two
[rfc37.txt]:  1.  Questioning the complexity and usefulness of the full protocol,
[rfc37.txt]:      especially the need for dynamic reconnection.
[rfc37.txt]:  2.  Other topics, particularly character set translation, higher
[rfc37.txt]:  Notably lacking was any criticism of the basic concepts of sockets
[rfc37.txt]:      immediately if he wished to modify the protocol.
[rfc37.txt]:  In all of our writing we have used the term process, to mean a
[rfc37.txt]:  etc.) to cause such a creation.  Processes may either cause their
[rfc37.txt]:  own demise or be terminated by another (usually superior) process.
[rfc37.txt]:  The above definition corresponds to the definition given by
[rfc37.txt]:  Vyssotsky, et al on pp.  206, 207 of "Structure of the Multics
[rfc37.txt]:  Supervisor" in the FJCC proceedings, 1965.
[rfc37.txt]:  Because a process may create another process, and because in general
[rfc37.txt]:  the two processes are indistinguishable when viewed externally, I
[rfc37.txt]:  directly with each other.  The function of sockets is to provide a
[rfc37.txt]:  In the time since the meeting I have had conversations with Steve
[rfc37.txt]:  Wolfe (UCLA-CCN), Bill Crowther (BBN), and John Heafner and Erick
[rfc37.txt]:  Crowther submitted the following:
[rfc37.txt]:  "A brief description of two ideas for simplifying the host protocol
[rfc37.txt]:  described at the March meeting.  These ideas have not been carefully
[rfc37.txt]:  reconnect".  They wait until there are no messages in transit and
[rfc37.txt]:  respond "OK".  He then says "Reconnect as follows" and they do it.
[rfc37.txt]:  In the Rare condition, the NCP gets back an "I want to reconnect
[rfc37.txt]:  instead of an "OK", then one must go and one must stop.  So treat a
[rfc37.txt]:  as a "No-wait until I reconnect you" and do the connection.
[rfc37.txt]:  use any handy link for the messages.  Don't send another message on
[rfc37.txt]:  destination socket numbers in the packet.
[rfc37.txt]:  follows...".  Hold onto the connect for a short time (seconds) and
[rfc37.txt]:  send both packets and connection messages along toward their
[rfc37.txt]:  destinations.  I haven't worked out how to keep the in-transit
[rfc37.txt]:  Bill's first idea does not seem to me to be either decisively better
[rfc37.txt]:  Bill's second idea seems contrary to my conception of the role of
[rfc37.txt]:  that the number of connections between two hosts might want to
[rfc37.txt]:  dependancies in design.  On the other hand, the newly provided Cease
[rfc37.txt]:  on Link facility* (page 22 of the soon to be released BBN report
[rfc37.txt]:  the feature in, doesn't care.)  Another objection is that it seems
[rfc37.txt]:  intuitively bad to waste the possibility of using the link field to
[rfc37.txt]:  carry information.  (Note the conflict of gut level feelings).
[rfc37.txt]:  In a conversation with John Haefner and Eric Harslem of RAND, the
[rfc37.txt]:  pointed out that the current protocol makes no provision for error
[rfc37.txt]:  only a fraction of the 256 links be used, say the first 32.  The
[rfc37.txt]:  other area is to use command codes from 255 downward, with permanent
[rfc37.txt]:  codes assigned from the number of links in use to 32, I feel that it
[rfc37.txt]:  time, and moreover, the network probably wouldn't handle traffic
[rfc37.txt]:  Some of Heafner's and Harslen's other ideas may appear in NWG/RFC
[rfc37.txt]:  During the next several days, I will still be interested in those
[rfc37.txt]:  serious modification of it.  Thereafter, the focus will be a
[rfc37.txt]:  825-2368.  Also, everyone is invited to contribuet to the NWG/RFC
[rfc37.txt]:        [ into the online RFC archives by Ron Fitzherbert 1/97 ]
[rfc38.txt]:   The proposed protocol does not allow for the possible multiplexing of
[rfc38.txt]:   restrictions in the future. Two cases where routing multiple
[rfc38.txt]:   connections over the same link are apparent:
[rfc38.txt]:            between processes that transmit files over the network.
[rfc38.txt]:            Assigning these connections to the same link limits the
[rfc38.txt]:            store-and-forward IMP's are used by the network to effect
[rfc38.txt]:            the communication.
[rfc38.txt]:         b) When two hosts each have their own independent network and
[rfc38.txt]:            desire to allow access to the other hosts's network over
[rfc38.txt]:            the ARPA net, a shortage of links may develop. Again, the
[rfc38.txt]:            assignment of several connections to the same link could
[rfc38.txt]:            help solve the problem.
[rfc38.txt]:   The following changes in the protocol would make possible the future
[rfc38.txt]:   use of multiplexed links. It is not necessary to add the
[rfc38.txt]:   multiplexing, itself, to the protocol at this time.
[rfc38.txt]:            the link number. Only the local socket name need be
[rfc38.txt]:         b) Problems arise with the RSM and SPD commands. Should they
[rfc38.txt]:            Since there is a proposal to modify the RFNM to accommodate
[rfc38.txt]:            these commands, it might be better to add another set of
[rfc38.txt]:            convinced that that is the best solution.
[rfc38.txt]:         c) The destintation socket must be added to the header of each
[rfc38.txt]:            message on the data link. Presumably this would consist of
[rfc38.txt]:            32 bits immediately after the header and before the marking.
[rfc38.txt]:         [ into the online RFC archives by Karl Reinsch 1/97 ]
[rfc39.txt]:   We offer the following suggestions to be considered as additions to
[rfc39.txt]:   the April 28th 1970 protocol grammar specifications.
[rfc39.txt]:   It is desirable to include debugging aids in the initial protocol for
[rfc39.txt]:   resource allocation or exhaustion. <Code> specifies the class and the
[rfc39.txt]:   offending member of the class.  The command is returned to the
[rfc39.txt]:   errors should be followed by a <CLS> in response to the <RFC>.
[rfc39.txt]:   Queries provide an extension to the <ERR> facility as well as limited
[rfc39.txt]:   The first command requests the remote NCP to supply the status of all
[rfc39.txt]:   connections to the user specified by the user number in <My socket>.
[rfc39.txt]:   The second is the reply; <Text> contains the connection status
[rfc39.txt]:   information.  If an NCP wants the status of all connections to a
[rfc39.txt]:   remote HOST, the <My Socket> is zero.
[rfc39.txt]:   This command supplements rather than replaces <CLS>.  It severs all
[rfc39.txt]:   which it is connected.  This command performs what would otherwise be
[rfc39.txt]:   handled by multiple <CLS> commands. <My Socket> contains the sender's
[rfc39.txt]:   to the more conventional post/poll method.
[rfc39.txt]:   Unlike the previous commands, these are not sent over the control
[rfc39.txt]:   link, but rather over links assigned to user programs.  The prefix of
[rfc39.txt]:   <TRN> or <BDC> indicates, to the receiving NCP, the disposition of
[rfc39.txt]:   the message body. <TRN> indicates a message to be passed to a single
[rfc39.txt]:   process. <BDC> specifies to the destination NCP that the message is
[rfc39.txt]:   to be distributed over all receiving connections linked to the
[rfc39.txt]:   sender.  In response to a system call by the user to an NCP
[rfc39.txt]:   requesting <BDC>, the NCP generates one <BDC> to each HOST to which
[rfc39.txt]:   the sender is connected.
[rfc39.txt]:   artificially imposed via the protocol (remote AEN assignment); and
[rfc39.txt]:   discounts the situation where only controlling process "A" has
[rfc39.txt]:   The <ERR>, etc., are suggestions for inclusion as additions in the
[rfc39.txt]:   course, not intended to affect modification of the RFC structure by
[rfc39.txt]:   studied the problem.  It is meant, however, to voice our concern
[rfc39.txt]:   problem and it deserves more study after we have exercised the
[rfc39.txt]:   suggestions with respect to the RFC in the future.
[rfc39.txt]:          [ into the online RFC archives by Mario Vitale 08/99 ]
[rfc4.txt]:       14b3  Try other programs
[rfc4.txt]:          [ into the online RFC archives by David Capshaw 11/97 ]
[rfc40.txt]:               More Comments on the Forthcoming Protocol
[rfc40.txt]:UCLA.  Steve has asked that we elaborate on the errors, queries, and
[rfc40.txt]:Please voice your opinions soon in order to affect the forthcoming
[rfc40.txt]:<Code> is an eight-bit field that specifies the error type.  The
[rfc40.txt]:that indicates the length of the <Command in error> in bits.  The
[rfc40.txt]:<Command in error> is the spurious command.
[rfc40.txt]:Specific values of <Code> are shown below with their meaning.
[rfc40.txt]:The <QRY> is the query indicated in NWG/RFC #39 and <RPY> is the reply.
[rfc40.txt]:indicates the NCP is available.  The sending NCP can then
[rfc40.txt]:construct a vector of HOST status from the RFNMs it receives.  An
[rfc40.txt]:NCP receiving a <NOP> can update the availability of the sending
[rfc40.txt]:         [ into the online RFC archives by Richard Ames 6/97 ]
[rfc41.txt]:know the time and date of the message.
[rfc41.txt]:old. The situation is not improved by the existence of sites that
[rfc41.txt]:now span all time zones of the U.S. and do not have direct voice
[rfc41.txt]:        It is requested that everyone tag their IMP to IMP tele-
[rfc41.txt]:type messages that cause no response at the receiving IMP.
[rfc41.txt]:the time zone designation.
[rfc41.txt]:   [ into the online RFC archives by Larry Campbell 7/97   ]
[rfc42.txt]:   We propose that the first eight bits of a normal message be reserved
[rfc42.txt]:   way signify agreement as to the actual data types to be used.  It
[rfc42.txt]:   merely establishes the convention that the first eight bits of every
[rfc42.txt]:   It is important that conventions regarding the contents of messages
[rfc42.txt]:   be set up early so that there will not be a large proliferation of
[rfc42.txt]:   such conventions between every pair of programs running on the
[rfc42.txt]:   both the syntax and semantics of messages.  However, even before such
[rfc42.txt]:   which initially put in and test and remove the type information from
[rfc42.txt]:   the message.  Let us call these two programs X and Y, for lack of
[rfc42.txt]:   the data, e.g., change character sets or number formats.  As network
[rfc42.txt]:   usage grows, X and Y might become table driven with the table
[rfc42.txt]:   specified by the user.
[rfc42.txt]:   transformation between every possible data representation and the
[rfc42.txt]:   data representation of the machine they are running on, and also
[rfc42.txt]:   since the addition of a data representation should not necessarily
[rfc42.txt]:   message types have meaning throughout the network.  These are
[rfc42.txt]:   message type MYLOCAL n implies: this is type n of the set of types of
[rfc42.txt]:   the sending host.  YOURLOCAL n implies: this is type n of the set of
[rfc42.txt]:   types of the receiving host.
[rfc42.txt]:   these cases, the second byte would be the local type number.
[rfc42.txt]:   Local type 0 would mean user-specified, i.e., the message contents
[rfc42.txt]:   are unchanged and unchecked.  Installations would define their own
[rfc42.txt]:   local type numbers and these would normally be available from the
[rfc42.txt]:   programs will be type 1, n where n is the local type number of the
[rfc42.txt]:   character set of the installation.
[rfc42.txt]:        5.     Load table driven translator table #n.  If, in the
[rfc42.txt]:               future, the X and Y transformation boxes are table
[rfc42.txt]:               driven, this gives the table.  The table number n is
[rfc42.txt]:               stored in the second byte of the message.
[rfc42.txt]:         [ into the online RFC archives by Robbie Bennet 11/98   ]
[rfc43.txt]:Language) for the TSP (Terminal Support Processor) system will be
[rfc43.txt]:      The purpose of the TSP system is to provide a flexible I/O
[rfc43.txt]:the system is user-programmable in an interpretable language called
[rfc43.txt]:      LIL has the appropriate primitives for manipulating tree
[rfc43.txt]:I/O. The general purpose portion of the language is used to specify
[rfc43.txt]:the I/O handlers and the display structures.
[rfc43.txt]:      A discussion of the problems of handling interactive programs
[rfc43.txt]:over the ARPA network will follow.
[rfc43.txt]:      Anyone interested in attending and/or receiving the documents
[rfc43.txt]:[This RFC was put into machine readable form for entry into the RFC
[rfc44.txt]:   Generally, we are satisfied with the suggestions for the new Host-
[rfc44.txt]:   I.   It seems that there are two cases of reconnection:
[rfc44.txt]:     1. Reconnect from a socket in a local Host to another socket in the
[rfc44.txt]:        local sockets can belong to different processes (such as the
[rfc44.txt]:        "Login" process switching a connection to another process just
[rfc44.txt]:        created) or can belong to the same process (such as a process
[rfc44.txt]:        after a connection is established switches to another of his
[rfc44.txt]:     We suggest separation of these two cases for the following reasons:
[rfc44.txt]:     a) Reconnection in Case 1 is necessary and useful, while the
[rfc44.txt]:        2 involves an elaborate mechanism of commands because of the
[rfc44.txt]:        asynchronous nature of the network (four out of nine commands
[rfc44.txt]:     Thus we think that at least in the first usage of the Host-to-Host
[rfc44.txt]:     system call (not a command) is therefore needed to permit Case 1,
[rfc44.txt]:        BLOCK and CLOSE.  As suggested in RFC #36, the response for both
[rfc44.txt]:        commands can be the SUSPEND command which acknowledges the
[rfc44.txt]:        keeping the "foreign socket" in a local connection table.  Since
[rfc44.txt]:        there is a one-to-one correspondence between a link number of
[rfc44.txt]:        the foreign Host and a foreign socket number, we can use the
[rfc44.txt]:        link number in the commands.  Thus, except for the RFC command,
[rfc44.txt]:        all commands can use link numbers and therefore eliminate a 40-
[rfc44.txt]:        bit foreign socket number in every entry of the connection table
[rfc44.txt]:        #38, then the foreign socket would be needed in the connection
[rfc44.txt]:   IV.  In RFC#33 the term PORT was introduced.  Although this is
[rfc44.txt]:        such that there is a one-to-one correspondence between a port
[rfc44.txt]:        for some user and a socket, then ports are completely redundant.
[rfc44.txt]:   To summarize the last four comments, we suggest that in the initial
[rfc44.txt]:   version the following system calls and commands will be used (most of
[rfc44.txt]:   them in RFC 33 and 36).
[rfc44.txt]:   V.   In addition to the above it seems necessary to decide on the
[rfc44.txt]:        following issues one way or the other together with the first
[rfc44.txt]:        version of the protocol (perhaps by setting a date for people to
[rfc44.txt]:        express their preferences and decide accordingly).  All of these
[rfc44.txt]:        issues were mentioned in the meeting at UCLA on March 17, 1970,
[rfc44.txt]:           a) Hosts provide their padding in addition to the IMP's
[rfc44.txt]:              by shifting their messages (when necessary) and adjusting
[rfc44.txt]:              the "marking" accordingly.
[rfc44.txt]:        2. "Echoing" - there are three apparent possibilities:
[rfc44.txt]:           c) Optional Echoing - possibly a bit in the "Leader" can be
[rfc44.txt]:        3. "Code Conversion" - originally, BB&N suggested doing the
[rfc44.txt]:           conversion in the IMPs  using ASCII-8 as the common code.
[rfc44.txt]:           conversion in the IMPs may slow them down and take up space
[rfc44.txt]:           desirable to have a common code (even when the conversion is
[rfc44.txt]:           not done by the IMPs), such that all incoming text messages
[rfc44.txt]:           are in the same code and only one conversion table is needed.
[rfc44.txt]:           code.  Obviously, the option "no translation" should be
[rfc44.txt]:           possible for the purpose of binary data or data that is not
[rfc44.txt]:           representable in the common code.  Since every known code can
[rfc44.txt]:           the 256 possible characters (for 8-bit code) to include the
[rfc44.txt]:           "important" part of the union of the codes used throughout
[rfc44.txt]:           the network.
[rfc44.txt]:   VI.   Our preference to the above issues is as follows:
[rfc44.txt]:           messages to be sent on a word boundary by shifting the leader
[rfc44.txt]:           of a message (and adjusting the "marking" accordingly) rather
[rfc44.txt]:           than the data.  Thus we will prefer solution V.1.b).
[rfc44.txt]:           Initially, ASCII-8 can be used, and then expanded according
[rfc44.txt]:           to the needs of the Network.
[rfc44.txt]:      [ into the online RFC archives by Alison De La Cruz 12/00 ]
[rfc45.txt]:We are currently preparing a clean version of the Network protocol,
[rfc45.txt]:will send these specs out on April 28.
[rfc45.txt]:Since the SJCC is one week later, we will host a discussion meeting in
[rfc45.txt]:Atlantic City, Thursday, May 7, win the afternoon.  The purpose of the
[rfc45.txt]:(Note that the network session, chaired by Larry Roberts with papers
[rfc45.txt]:         [ into the online RFC archives by Josh Elliott 1/98 ]
[rfc46.txt]:   The attached document contains comments and suggestions of the
[rfc46.txt]:   Network Working Group at Project MAC.  It is based upon the protocol
[rfc46.txt]:   This proposal is intended as a contribution to the dialog leading to
[rfc46.txt]:   a protocol specification to be accepted by the entire Network Working
[rfc46.txt]:   In this document the Network Working Group at MIT Project MAC suggest
[rfc46.txt]:   modifications and extensions to the protocol specified by Carr,
[rfc46.txt]:   Crocker, and Cerf in a preprint of their 1970 SJCC paper and extended
[rfc46.txt]:   intended to be an indication of the type and extent of the protocol
[rfc46.txt]:   We agree with the basic concept of simplex communication between
[rfc46.txt]:   sockets having unique identifiers.  We propose the implementation of
[rfc46.txt]:   a slightly modified subset of the network commands specified in
[rfc46.txt]:   NWG/RFC36 plus the ERR command as specified by Harslem and Heafner in
[rfc46.txt]:   Given the basic objective of getting all ARPA contractors onto the
[rfc46.txt]:   network and talking to each other at the earliest possible date, we
[rfc46.txt]:   reasonably simple yet extendable while providing for the major
[rfc46.txt]:   initial uses of the network.  It should be a simple protocol so as to
[rfc46.txt]:   elicit the broadest possible support and to be easily implementable
[rfc46.txt]:   While the protocol will evolve, the fundamentals of a protocol
[rfc46.txt]:   very resistant to change.  Thus it is very important to make the
[rfc46.txt]:   does not preclude the existence of additional layers of protocol
[rfc46.txt]:   between several installations so long as the basic protocol remains
[rfc46.txt]:   We feel that three facilities must be provided for in the initial
[rfc46.txt]:      how to connect to each other.
[rfc46.txt]:   2. A standard way for a process to connect to the logger (logging
[rfc46.txt]:      process at a HOST) at a foreign HOST and request the creation of a
[rfc46.txt]:      typewriter communication with the foreign process which requested
[rfc46.txt]:   The major differences between the protocol as proposed by Carr,
[rfc46.txt]:   Crocker, and Cerf and this proposal are the following:
[rfc46.txt]:      its inclusion would unduly complicate the initial implementation
[rfc46.txt]:      of the protocol.  We outline a strategy for foreign process
[rfc46.txt]:      this proposal precludes the implementation of dynamic reconnection
[rfc46.txt]:   2. We propose that an "instance tag" be added to the socket
[rfc46.txt]:      processes of the same user coexisting at one HOST.
[rfc46.txt]:         the "cease on link" IMP command and SPD and RSM commands set
[rfc46.txt]:         forth in NWG/RFC 36.  Because these commands operate on socket
[rfc46.txt]:         connections rather than link numbers, they do not impede the
[rfc46.txt]:         implement the interrupt as a special format within a normal
[rfc46.txt]:         message raises severe difficulties: the connection may be
[rfc46.txt]:         blocked when the interrupt is needed, and the NCP must scan
[rfc46.txt]:   4. Sockets are conceptualized as having several states, and these are
[rfc46.txt]:      This differs from the unlimited queuing feature, which presents
[rfc46.txt]:   It seems convenient and useful to view the network as consisting of a
[rfc46.txt]:   We view the initial network communications system as a hierarchy of
[rfc46.txt]:      is the basic resource which higher level systems convert into more
[rfc46.txt]:   2. Network Control Program - Each HOST contains a module called the
[rfc46.txt]:      communications between its HOST and the IMP network.  It acts as a
[rfc46.txt]:      "retailer" of the wholesale communications facilities provided by
[rfc46.txt]:      the IMP network.  The network of NCPs can be viewed as a higher
[rfc46.txt]:      level communications system surrounding the IMP network which
[rfc46.txt]:      of the primary initial uses of the network is thought to involve
[rfc46.txt]:      the creation of a foreign user process through interaction with
[rfc46.txt]:      the foreign HOST's logger.  The User Control and Communication
[rfc46.txt]:      to have the same privileges (subject to administrative control) as
[rfc46.txt]:      a local (to the foreign HOST) user process.  The UCC module
[rfc46.txt]:      communicates through the NCP in a manner similar to an ordinary
[rfc46.txt]:      process.  Except for the ability to close connections to a dead
[rfc46.txt]:      process, the UCC module has no special network privileges.  The
[rfc46.txt]:      systems connected through the NCP system might implement a load-
[rfc46.txt]:   Each HOST implements a module called the Network Control Program
[rfc46.txt]:   protocol issues involve:  (i) the definition of these communication
[rfc46.txt]:   paths, and (ii) a system for coordinating the distributed NCP system
[rfc46.txt]:   in maintaining these communication paths.  These are discussed below.
[rfc46.txt]:   process and a receive socket attached to another process.  Sockets
[rfc46.txt]:   have the following characteristics:
[rfc46.txt]:   Socket Identifier - A socket identifier is used throughout the
[rfc46.txt]:   having the following components:
[rfc46.txt]:         code assigned by the home HOST.  This user number is the same
[rfc46.txt]:         instance tag identifies the particular process to which a
[rfc46.txt]:         socket belongs.  A user's first process at a HOST to use the
[rfc46.txt]:      c. HOST Number (8 bits) - This is the code of the HOST on which
[rfc46.txt]:         the attached process exists.
[rfc46.txt]:         whether this is a "send" (= 1) or "receive" (= 0) socket.
[rfc46.txt]:   implement more transitory states of a socket, but the three following
[rfc46.txt]:      a. Inactive - there is no currently existing process which has
[rfc46.txt]:         told the NCP that it wishes to listen to this socket.  No other
[rfc46.txt]:      c. Connected - This socket is currently connected to another
[rfc46.txt]:   Socket Event Queue - A queue of events to be disclosed to the owning
[rfc46.txt]:   of a chronologically ordered list of certain events generated by the
[rfc46.txt]:   disconnect this socket.  An entry in the event queue consists of the
[rfc46.txt]:   event type plus the identifier of the foreign socket concerned.  The
[rfc46.txt]:   A "request" event is removed from the queue when it is accepted or
[rfc46.txt]:   rejected.  The other events are removed from the queue as they are
[rfc46.txt]:   disclosed to the owning process.
[rfc46.txt]:   Some events are intended to be transparent to the process owning the
[rfc46.txt]:   socket, and they do not generate entries in the event queue.
[rfc46.txt]:   a socket is full, any incoming event that would add to the queue
[rfc46.txt]:   should be discarded and the sending NCP notified (via ERR command
[rfc46.txt]:   concern the creation and manipulation of socket connections
[rfc46.txt]:   controlled by the NCP receiving the command.  A control command is
[rfc46.txt]:   over link number 1 (designated as the control link), which is
[rfc46.txt]:   between these messages and regular data messages implementing
[rfc46.txt]:      If the foreign socket is open, the foreign NCP places a "request"
[rfc46.txt]:      event into the socket's event queue for disclosure to the process
[rfc46.txt]:      that owns it.  If the foreign process accepts, the foreign NCP
[rfc46.txt]:      returns a positive acknowledgement in the form of another RFC.  It
[rfc46.txt]:      rejects connection by issuing the CLS command (see below).  An RFC
[rfc46.txt]:      is automatically rejected without consulting the owning process if
[rfc46.txt]:      the foreign socket is not open (inactive or connected).  Multiple
[rfc46.txt]:      RFCs to the same socket are placed into its event queue in order
[rfc46.txt]:      of receipt.  Any queued RFCs are automatically rejected by the NCP
[rfc46.txt]:      once the owning process decides to accept a connection.  The NCP
[rfc46.txt]:      which has control of the "receive" socket of the potentially
[rfc46.txt]:      that the CLS command may reach the foreign NCP prior to the last
[rfc46.txt]:      socket is not transmitted until the RFNM for the last message to
[rfc46.txt]:      the foreign socket comes back, and (ii) the foreign NCP processes
[rfc46.txt]:      all incoming messages in the order received.
[rfc46.txt]:      messages are coming in and thus the NCP's buffers may tend to clog
[rfc46.txt]:      up.  The NCP issues this command to a foreign NCP to block further
[rfc46.txt]:      transmission over the socket pair until the receiving process
[rfc46.txt]:      e. Interrupt the Process Attached to a Connection
[rfc46.txt]:      Receipt of this message causes the foreign NCP to immediately
[rfc46.txt]:      interrupt the foreign process attached to <foreign socket> if it
[rfc46.txt]:      the NCP network over the interrupted connection will be
[rfc46.txt]:      transmitted to the destination socket.  The meaning of "interrupt"
[rfc46.txt]:      is that the process will immediately break off its current
[rfc46.txt]:      messages, or overload conditions that prevent processing of the
[rfc46.txt]:      command.  <code> specifies the error type.  If <code> specifies an
[rfc46.txt]:      message, <command in error> contains only the link number over
[rfc46.txt]:      which the erroneous message was transmitted.  (This is slightly
[rfc46.txt]:      modified from the specification in NWG/RFC 40.)
[rfc46.txt]:      An NCP may test the quality of communications between it and a
[rfc46.txt]:      <48 bit code> (of the same length as a socket identifier) and
[rfc46.txt]:      immediately send an acknowledging ECO with the same <48 bit code>
[rfc46.txt]:      and <echo switch> 'off' to the originating NCP.  An NCP does not
[rfc46.txt]:      command will be of considerable aid in the initial shakedown of
[rfc46.txt]:      the entire network.
[rfc46.txt]:User Interface to the NCP
[rfc46.txt]:   can exercise the network, subject to the control of the NCP.  The
[rfc46.txt]:   its particular requirements.  The protocol requirements for the user
[rfc46.txt]:   privileges include the ability to masquerade as another process,
[rfc46.txt]:   eavesdrop on communications not intended for it, or to induce the NCP
[rfc46.txt]:   We outline here an interface based on the Carr, Crocker, and Cerf
[rfc46.txt]:   proposal that is sufficient to fully utilize the network.  While this
[rfc46.txt]:   it indicates the types of functions necessary.
[rfc46.txt]:      The following calls to the NCP are available:
[rfc46.txt]:      This LISTEN call may block waiting for the first "request" event,
[rfc46.txt]:      local NCP sends an RFC to the foreign NCP requesting that the
[rfc46.txt]:      connection be created.  The returned acknowledgemnet is either an
[rfc46.txt]:      RFC (request accepted) or CLS (request rejected).  At the caller's
[rfc46.txt]:      option, the INIT call blocks on the expected "accept" or "reject"
[rfc46.txt]:      the user must call STATUS (see below) at a later time to determine
[rfc46.txt]:      the action by the foreign NCP.  When a blocked INIT call returns,
[rfc46.txt]:      the "accept" or "reject" event is removed from the event queue.
[rfc46.txt]:      This call reports out the earliest previously unreported event in
[rfc46.txt]:      the queue of <my socket>.  The STATUS call deletes the event from
[rfc46.txt]:      the queue if that type of event is deleteable by disclosure.
[rfc46.txt]:      The user accepts connection with the foreign socket whose
[rfc46.txt]:      "request" event is earliest in the event queue for <my socket>.
[rfc46.txt]:      An acknowledging RFC is sent to the accepted foreign socket, and
[rfc46.txt]:      the "request" event is deleted from the event queue.  Should any
[rfc46.txt]:      other "request" event exist in the queue, the NCP automatically
[rfc46.txt]:      denies connection by sending out a CLS command and deleting the
[rfc46.txt]:      The user rejects connection with the foreign socket whose
[rfc46.txt]:      "request" event is earliest in the event queue for <my socket>.
[rfc46.txt]:      The NCP sends out a CLS command and deletes the "request" event
[rfc46.txt]:      from the queue.
[rfc46.txt]:      The user directs the NCP to disconnect any active connection to
[rfc46.txt]:      this socket and to deactivate the socket.  The NCP sends out a CLS
[rfc46.txt]:      command to the foreign socket if a connection has existed.  The
[rfc46.txt]:      status of the foreign socket also becomes closed once the "close"
[rfc46.txt]:      event is disclosed to the foreign process.
[rfc46.txt]:      The user directs the NCP to send out an INT command to the foreign
[rfc46.txt]:      by <pointer>.  A call to write returns immediately after the NCP
[rfc46.txt]:      has queued the data to send a message over the connection.  The
[rfc46.txt]:      call to write blocks only if the connection is blocked or if the
[rfc46.txt]:      local NCP is too loaded to process the request immediately.  Data
[rfc46.txt]:      IMP messages of maximum length 8095 bits and transmitted to the
[rfc46.txt]:      foreign HOST over the link number specified in the RFC sent by the
[rfc46.txt]:      NCP controlling the receiving connection.  A "close" event in the
[rfc46.txt]:      event queue for <my socket> is disclosed through the action of
[rfc46.txt]:      TRANSMIT.  A call to write discloses the "close" event
[rfc46.txt]:   1. Establishing the Connection
[rfc46.txt]:      available set of links.  This is the link over which it will
[rfc46.txt]:      receive messages if the connection is ACCEPTed by process 'b'.
[rfc46.txt]:      d. If process 'b' ACCEPTs, the confirming RFC establishes the
[rfc46.txt]:      a. Process 'b' issues a TRANSMIT call to send data through the
[rfc46.txt]:      b. NCP A receives the raw message from NCP B with link number =
[rfc46.txt]:      47.  NCP A uses this link number in deciding who the intended
[rfc46.txt]:      recipient is, and stores the message in a buffer for the recipient
[rfc46.txt]:      at any arbitrary time.  The read call blocks if there is no data
[rfc46.txt]:      pending for the socket.  The read call picks up the specified
[rfc46.txt]:      IMP message boundary.  The boundaries of the IMP messages are
[rfc46.txt]:      invisible to the read call.
[rfc46.txt]:      d. Should process 'b' send data over the connection at a faster
[rfc46.txt]:   3. Process 'b' Closes the Connection
[rfc46.txt]:      a. Process 'b' decides to close the connection, and it issues the
[rfc46.txt]:      CLOSE call to NCP B.  To avoid race problems B waits for the RFNM
[rfc46.txt]:      from the previous message over this connection, then sends the CLS
[rfc46.txt]:      command to NCP A.  When the RFNM from the CLS command message
[rfc46.txt]:      returns, NCP B flushes socket 'Bb9' from its tables, effecting the
[rfc46.txt]:      b. Because of sequential processing within NCP A, the last message
[rfc46.txt]:      before the CLS from NCP B comes through.  Upon receipt of the CLS
[rfc46.txt]:      "close" event into the event queue of 'Aa12'.
[rfc46.txt]:      there is buffered data pending.  When 'a' issues a read call after
[rfc46.txt]:      the buffer has been emptied, the "close" event is disclosed to
[rfc46.txt]:      inform 'a' of the closure, and socket 'Aa12' is flushed from the
[rfc46.txt]:   4. Process 'a' Closes the Connection
[rfc46.txt]:      close the connection from its end.  There is no race problem
[rfc46.txt]:      transit from process 'b' to percolate through the IMP network to
[rfc46.txt]:      the RFNM from the CLS command.  During this period NCP A discards
[rfc46.txt]:      all messages received over the closing connection.  After allowing
[rfc46.txt]:      a reasonable amount of time for these dead messages to come in,
[rfc46.txt]:      NCP A flushes 'Aa12' from its tables, effectively closing the
[rfc46.txt]:      connection and deactivating 'Aa12'.  Further messages to socket
[rfc46.txt]:      'Aa12' result in NCP A sending an ERR "erroneous command" to the
[rfc46.txt]:      c. When NCP B receives the CLS command, socket 'Bb9' is marked as
[rfc46.txt]:      "close pending", and the CLS event is placed into the event queue
[rfc46.txt]:      socket, the CLS event is disclosed to inform him of the closure,
[rfc46.txt]:   Some process must exist which agrees to listen to anybody in the
[rfc46.txt]:   This process is called the logger and interacts through the NCP via
[rfc46.txt]:   the network-related User Control and Communication (UCC) module,
[rfc46.txt]:   which implements the necessary protocol.  Except for one instance
[rfc46.txt]:   (CLOSEing connections of dead processes), the process operating the
[rfc46.txt]:   Under the UCC protocol a "requestor" process which has directed the
[rfc46.txt]:   typewriter connections:  one to the foreign logger, and one to the
[rfc46.txt]:   created process.  The duplex connection to the foreign logger is used
[rfc46.txt]:   to identify the requestor process to the logger, and after login to
[rfc46.txt]:   return to the requestor process basic information concerning the
[rfc46.txt]:   health of the created process.  The duplex connection to the created
[rfc46.txt]:   both when the logger transfers communication to the created process
[rfc46.txt]:   and when it needs to regain control.  This is at the modest expense
[rfc46.txt]:   of requiring the requestor process to switch typewriter
[rfc46.txt]:   the requestor process first reserves four of its sockets having
[rfc46.txt]:   contiguous socket codes.  Then it "signals" the UCC, specifying one
[rfc46.txt]:   of these sockets.  From the "signal" the UCC knows which process is
[rfc46.txt]:   calling, and by protocol, on which requestor socket pair the UCC is
[rfc46.txt]:   to communicate with the requestor process, and which requestor socket
[rfc46.txt]:   pair the created process is to use for its communications.  This is
[rfc46.txt]:   to create a process at this HOST must first signal the UCC by issuing
[rfc46.txt]:   typewriter communication with the foreign UCC, the low numbered set
[rfc46.txt]:   for typewriter communication with the created process.
[rfc46.txt]:   1. The "requestor" process calls LISTEN twice to open the
[rfc46.txt]:   will talk to the foreign UCC.  Then it sends out a "signalling" INIT
[rfc46.txt]:   call on <base_socket> to the UCC "signal" socket.  The only thing
[rfc46.txt]:   that the UCC does with this "signalling" INIT call is to note down
[rfc46.txt]:   the socket number <base_socket> from which it originated.  The UCC
[rfc46.txt]:   open for other signals.
[rfc46.txt]:   2. After receiving the expected REJECT on its initial INIT call to
[rfc46.txt]:   the UCC's signal socket, the requestor process issues LISTENs for
[rfc46.txt]:   these sockets to establish control communication with the requestor
[rfc46.txt]:   process.)  The requestor process then blocks by calling STATUS
[rfc46.txt]:   3.  The UCC INITs a free send/receive socket pair to the requestor's
[rfc46.txt]:   <base_socket+2> and <base_socket+3> on which the requestor process is
[rfc46.txt]:   <base_socket+2> with block option after LISTENing for the two
[rfc46.txt]:   sockets, so that when the INIT from the foreign UCC reaches the
[rfc46.txt]:   requestor process, STATUS returns with the INIT indication.  The
[rfc46.txt]:   requestor process verifies that the UCC is the process that is
[rfc46.txt]:   calling, then it ACCEPTs the call.  The requestor process then calls
[rfc46.txt]:   STATUS <base_socket+3> and returns when the INIT for that socket
[rfc46.txt]:   arbitrary choice as for which socket the requestor process first
[rfc46.txt]:   calls STATUS.)  Two way communication is established when the
[rfc46.txt]:   requestor process has ACCEPTed both INITs from the UCC.  This
[rfc46.txt]:   connection is maintained during the login ritual and throughout the
[rfc46.txt]:   life of the created process.  Should the requestor process fail to
[rfc46.txt]:   respond properly within a limited amount of time to the INITs of the
[rfc46.txt]:   UCC, the UCC abandons the connection attempt.
[rfc46.txt]:   4. The requestor process must then perform the login ritual with the
[rfc46.txt]:   UCC.  (The initial protocol might standardize the login ritual.)  If
[rfc46.txt]:   the logger is not satisfied and wishes to cut off the requestor, the
[rfc46.txt]:   after the logger has sent a suitable message.
[rfc46.txt]:   5.  If satisfied, the logger creates a process for the user.  The UCC
[rfc46.txt]:   maintains direct communication with the requestor, but this
[rfc46.txt]:   the created process.
[rfc46.txt]:   created process INITs one of its send/receive socket pairs to the
[rfc46.txt]:   ACCEPTed, the created process sends an initial message over this
[rfc46.txt]:   typewriter command message over the connection.  If the created
[rfc46.txt]:   process is unable to establish duplex communication with the
[rfc46.txt]:   requestor process, it should destroy itself.  The UCC will either
[rfc46.txt]:   CLOSE its own connections with the requestor or make arrangements for
[rfc46.txt]:   another process to be created.
[rfc46.txt]:   7. When a created process is logged-out, the UCC uses a privileged
[rfc46.txt]:   entry to the NCP to CLOSE all connections between the dead process
[rfc46.txt]:   and other processes, and to deactivate all open sockets of the dead
[rfc46.txt]:   process.  The UCC transmits a message back to the requestor process,
[rfc46.txt]:   then CLOSEs the dual connections between it and the requestor
[rfc46.txt]:   requestor process to a created process over the requestor's receive
[rfc46.txt]:   socket <base_socket>.  All pending output from the created process is
[rfc46.txt]:   aborted, and the it enters "command level" where it awaits a command
[rfc46.txt]:   over the typewriter connection to the requestor process.  The
[rfc46.txt]:   the created process.  (Note that the rule about pending output is
[rfc46.txt]:   more restrictive than that implemented by the INT NCP command.)
[rfc46.txt]:      This document was prepared through the use of the MULTICS "runoff"
[rfc46.txt]:      requests was created using the "qed" text editor.  This file was
[rfc46.txt]:      then compiled by the "runoff" command to produce a finished copy.
[rfc46.txt]:      the segment
[rfc46.txt]:      <base_socket> and                            pair to the requestor's
[rfc46.txt]:      connected to the created  process.          <base_socket+3>.
[rfc46.txt]:          [ into the online RFC archives by Miles McCredie 11/99  ]
[rfc47.txt]:BBN has given us the attached comments on NWG/RFC 33, but wouldn't
[rfc47.txt]:publish them being relectant to embarrass us.  Embarrassment notwith-
[rfc47.txt]:standing, we found the comments particularly useful and decided to share
[rfc47.txt]:them with our friends.  Bill Crowther is the author.
[rfc47.txt]:I found two substantial errors in the Host Protocol Paper, which was
[rfc47.txt]:otherwise an excellent paper.  Both concern a misunderstanding of the
[rfc47.txt]:nature of the IMP as a communications device, and in particular the
[rfc47.txt]:nature of buffering an IMP must do.  The authors consider the network as
[rfc47.txt]:waits in buffers for substantial lengths of times, and then emerges at
[rfc47.txt]:the destination.  In fact a better model would be that the message pops
[rfc47.txt]:out again an instant after it is inserted.  While it is true there is a
[rfc47.txt]:delay, it is imposed by phone line hardware for the most part.  The IMP
[rfc47.txt]:problem.  The desire is to regulate traffic in such a way that as the
[rfc47.txt]:Host takes its message from the IMP the next message is arriving on the
[rfc47.txt]:In fact we cannot achieve this, and therefore have included buffering to
[rfc47.txt]:handle traffic surges.  These buffers are useless for their intended
[rfc47.txt]:purpose unless they are empty.  Only empty buffers are available to soak
[rfc47.txt]:The two specific errors occur on pages 5 and 23.  On page 5 the authors
[rfc47.txt]:say "Implicit in this purpose is the assumption that a user does not use
[rfc47.txt]:multiple links to achieve a wide band."  In fact one of the primary
[rfc47.txt]:have rightly noticed that multiple links subvert the RFNM mechanism,
[rfc47.txt]:making our job harder, but have wrongly labeled the nature of the
[rfc47.txt]:Again on page 5 "An even more basic assumption, of course, is that the
[rfc47.txt]:rather than many users transmitting single messages coincidentally."  We
[rfc47.txt]:are in great shape against single message users when their messages are
[rfc47.txt]:special procedures for the (rare) coincedences.  Our problems come with
[rfc47.txt]:the non-random coincidences, and we have taken special precautions
[rfc47.txt]:On pages 23 and 24 there are 4 critical sentences which imply that the
[rfc47.txt]:system design could have been improved by allowing the Host to specify
[rfc47.txt]:the Host needs to buffer these messages for its users, but violently
[rfc47.txt]:disagree that the IMP has the capability to do this buffering.
[rfc47.txt]:the Host at any time.  If we have more than one we urgently need the
[rfc47.txt]:Host to accept these messages, because our ability to handle traffic
[rfc47.txt]:up in the network.  "Three" is not enough to help the Host in addition
[rfc47.txt]:to keeping a reserve for the traffic surges.
[rfc47.txt]:But if buffering is needed why not get more memory and do it in the IMP?
[rfc47.txt]:needed at all in some places, and is better done where the extra memory
[rfc47.txt]:can be efficiently shared by the Host operating system.
[rfc47.txt]:I repeat:  the IMP's buffers must be empty or they are not serving their
[rfc47.txt]:      [ into the online RFC archives by Jeff & Christy McClellan 2/98]
[rfc48.txt]:   We have been engaged in two activities since the network meeting of
[rfc48.txt]:   First, we have considered the various modifications suggested from
[rfc48.txt]:   all quarters and have formed preferences about each of these.  In
[rfc48.txt]:   Section II we give our preferences on each issue, together with our
[rfc48.txt]:   Second, we have tried to formalize the protocol and algorithms for
[rfc48.txt]:   the NCP, we attempted to do this with very little specification of a
[rfc48.txt]:   only a brief sketch of the structure of the NCP.  Section III gives
[rfc48.txt]:   our assumptions about the environment of the NCP and in Section IV
[rfc48.txt]:   the components of the NCP are described.
[rfc48.txt]:   In this section we try to present each of the several questions which
[rfc48.txt]:   good ideas are rejected because in our estimation they should be
[rfc48.txt]:         As BBN report #1822 explains, the Imp side of the Host-to-Imp
[rfc48.txt]:         out a message to an Imp word boundary and yet preserve the
[rfc48.txt]:         message length.  Furthermore, the Host side of the Imp-to-Host
[rfc48.txt]:         interface extends a message with 0's to fill out the message to
[rfc48.txt]:         BBN's mechanism works fine if the sending Host wants to send an
[rfc48.txt]:         integral number of words, or if the sending Host's hardware is
[rfc48.txt]:         capable of sending partial words.  However, in the event that
[rfc48.txt]:         the sending Host wants to send an irregular length message and
[rfc48.txt]:         One of the simplest solutions is to modify the Imp side of the
[rfc48.txt]:         mean that the Host software would have to supply the trailing
[rfc48.txt]:         1.  BBN rejected the change because of an understandably strong
[rfc48.txt]:         five instruction patch to the Imp program would remove the
[rfc48.txt]:         interface supplied 1, but this was also rejected on the new
[rfc48.txt]:         grounds that it seemed more secure to depend only upon the Host
[rfc48.txt]:         hardware to signal message end, and not to depend upon the Host
[rfc48.txt]:         Two other solutions are also available.  One is to have "double
[rfc48.txt]:         padding", whereby the sending Host supplies 10* and the network
[rfc48.txt]:         also supplies 10*.  Upon input, a receiving Host then strips
[rfc48.txt]:         the trailing 10* 10*.  The other solution is to make use of the
[rfc48.txt]:         marking.  Marking is a string of the form 0*1 inserted between
[rfc48.txt]:         the leader and the text of a message.  The original intent of
[rfc48.txt]:         marking was to extend the leader so that the sending Host could
[rfc48.txt]:         use the marking to expand a message so that it _ends_ on a word
[rfc48.txt]:         Notice that double padding could replace marking altogether by
[rfc48.txt]:         abutting the text beginning against the leader.  For 32 bit
[rfc48.txt]:         other lengths, particularly 36 bit machines, marking is much
[rfc48.txt]:         adjusting the marking does not cause them any problems, and
[rfc48.txt]:         they have a 32 bit machine.  Since the idea of marking has been
[rfc48.txt]:         used and that marking be used to adjust the length of a
[rfc48.txt]:         message.  We note that if BBN ever does remove the 1 from the
[rfc48.txt]:         needed on the send side.
[rfc48.txt]:         by W. Sutherland.  He suggested that the Host/Imp interfaces be
[rfc48.txt]:         the message upon input.
[rfc48.txt]:         including dynamic reconnection in the protocol.  We felt it
[rfc48.txt]:         After considering connections and their uses for a while, we
[rfc48.txt]:         wondered how the mechanism of connections compared to existing
[rfc48.txt]:         are of interest, what formalisms have been presented in the
[rfc48.txt]:         interesting because they lead to uniform implementations and
[rfc48.txt]:         because they point out which problems need solving and
[rfc48.txt]:         particular, we have noticed that the mechanisms for connecting
[rfc48.txt]:         a console to the logger upon dial in, the mechanisms for
[rfc48.txt]:         creating a job, and the mechanisms for passing a console around
[rfc48.txt]:         idiosyncratic and distinct from all other structures and
[rfc48.txt]:         With respect to the literature, it appears there is only one
[rfc48.txt]:         portion of their address spaces and cooperatively wake up each
[rfc48.txt]:         other.  Semaphores and event channels are handy extensions of
[rfc48.txt]:         wake up signals, but the intent is basically the same.  (Event
[rfc48.txt]:         not to be within their intended use.  In small systems, the
[rfc48.txt]:         systems allow a process to appear to be a file to another
[rfc48.txt]:         process.  Some systems, e.g. the SDS-940 at SRI impose a
[rfc48.txt]:         but other systems provide for a coequal relationship e.g. the
[rfc48.txt]:         process with a mapping from device and file names to other
[rfc48.txt]:         device and file names.  Consoles have nearly the same semantics
[rfc48.txt]:         believe it is communicating with the console but in fact be
[rfc48.txt]:         communicating with another process.
[rfc48.txt]:         network connections are probably the correct structure for
[rfc48.txt]:         using the network.  Moreover, the structure is clean enough and
[rfc48.txt]:         theory, at least to the extent of the other forms of
[rfc48.txt]:         interprocess communication presented in the literature.
[rfc48.txt]:         Any new formalism, we believe, must meet at least the following
[rfc48.txt]:         In the case of network connections, the candidates for the
[rfc48.txt]:         first are the ones given above, i.e. all operations involving
[rfc48.txt]:         are the modelling of sequential devices such as tape drives,
[rfc48.txt]:         printers and card readers, and the modeling of their buffering
[rfc48.txt]:         The second question mentions closure.  In applying the
[rfc48.txt]:         connection formalism to the dial-in and login procedures, we
[rfc48.txt]:         felt the need to include some sort of switching or
[rfc48.txt]:         only the substitution of AEN's, and even then only at the time
[rfc48.txt]:         to extend its definition.  Therefore, we considered the
[rfc48.txt]:            1. Switching to any other socket, possibly in another Host.
[rfc48.txt]:         There is even some precedent for feeling these extensions might
[rfc48.txt]:         the logger.  The logger answers calls, screens users, and
[rfc48.txt]:         creates jobs and processes.  One of the features of most
[rfc48.txt]:         serve the same phone number by using a block of sequential
[rfc48.txt]:         provide equivalent service to network users, i.e. they should
[rfc48.txt]:         the logger.  Thus a prima facie case for switching is
[rfc48.txt]:         Next we see that after the logger interrogates a prospective
[rfc48.txt]:         user, it must connect the user to a newly created job.  Data
[rfc48.txt]:         flow between the user and the logger has already commenced, so
[rfc48.txt]:         imagine a utility service which is distributed throughout the
[rfc48.txt]:         network and which passes connections from one socket to another
[rfc48.txt]:         without the knowledge of the user.  Also, it is similar to the
[rfc48.txt]:         These considerations led us to investigate the possibility of
[rfc48.txt]:         because of inexperience with finite state automata theory, but
[rfc48.txt]:         eventually we produced the algorithm presented in NWG/RFC #36.
[rfc48.txt]:         A short time later, Bill Crowther produced an equivalent
[rfc48.txt]:         Networkers seem to have one of two reactions.  Either it was
[rfc48.txt]:         far more evident to us, and we were put into the defensive
[rfc48.txt]:         In response to persistent criticism, we have made the following
[rfc48.txt]:         change in the protocol.  Instead of calling socket <O,H,O> to
[rfc48.txt]:         login, sockets of the form <U,H,O> and <U,H,1> are the input
[rfc48.txt]:         and output sockets respectively of a copy of the logger or, if
[rfc48.txt]:         a job has been stared with user id U, these sockets are the
[rfc48.txt]:         copy of the logger will respond and interrogate the caller.  If
[rfc48.txt]:         user id U is in use, the call will be refused.  This
[rfc48.txt]:         modification was suggested by Barry Wessler recently.  (Others
[rfc48.txt]:         then.)
[rfc48.txt]:         The logger may demand that the caller be from the same virtual
[rfc48.txt]:         net, i.e. the caller may have user id U in some other Host, or
[rfc48.txt]:         it may demand that the user supply a password matched to user
[rfc48.txt]:         After login, AEN's 0 and 1 remain the console AEN's.  Each
[rfc48.txt]:         system presumably has mechanisms for passing the console, and
[rfc48.txt]:         these would be extended to know about AEN's 0 and 1 for network
[rfc48.txt]:         users.  Passing the console is thus a matter of reconnecting
[rfc48.txt]:         sockets to ports, and happens within the Host and without the
[rfc48.txt]:         received, they suggested a login scheme different from both
[rfc48.txt]:         little better and we look forward to their next note.
[rfc48.txt]:         is, above the NCP level.  We are beginning to be indifferent
[rfc48.txt]:         burden, of course, to modify the local login procedure, but we
[rfc48.txt]:         procedures.  This is because the text sequences and interrupt
[rfc48.txt]:         conventions are so heterogenous that the additional burden of
[rfc48.txt]:         We are agreed that reconnection should not be required in the
[rfc48.txt]:         Bill Crowther (BBN) and Steve Wolfe (UCLA) independently have
[rfc48.txt]:         Instead, they suggest, include the destination socket as part
[rfc48.txt]:         of the text of the message and then send messages over any
[rfc48.txt]:         there is yet an argument for either case.  With the current
[rfc48.txt]:         We, therefore, recommend this.
[rfc48.txt]:         is to guard against any input which destroys the consistency of
[rfc48.txt]:         the NCP's data base.
[rfc48.txt]:         The specific formulation of the error command given by Heafner
[rfc48.txt]:         A distinction should be made between resource errors and other
[rfc48.txt]:         types of errors.  Resource errors are just the detection of
[rfc48.txt]:         valid, although perhaps undesirable.  Other types of errors
[rfc48.txt]:         mechanisms specific to the problem.  Thus the <CLS> command may
[rfc48.txt]:         be issued when there is no more room to save waiting <RFC>'s.
[rfc48.txt]:         With respect to true errors, we are not certain what the value
[rfc48.txt]:         of the <ERR> command is to the recipient.  Presumably his NCP
[rfc48.txt]:         is broken, and it may only aggravate the problem to bombard it
[rfc48.txt]:         with error commands.  We therefore, recommend that error
[rfc48.txt]:         In the short time the network has been up at UCLA, we have
[rfc48.txt]:         become convinced that the network itself will generate very few
[rfc48.txt]:         errors.  We have watched the BBN staff debug and test the IMP
[rfc48.txt]:         program, and it seemed that most of the errors affected timing
[rfc48.txt]:         and throughput rather than validity.  Hence most errors will
[rfc48.txt]:         this is to permit NCP's to send status whenever they wish, but
[rfc48.txt]:         to always have them do it whenever they receive a request.
[rfc48.txt]:         messages should use as little of the normal machinery as
[rfc48.txt]:         the suggestion on page 2 of NWG/RFC #40.
[rfc48.txt]:         Meyer's <ECO> command is easily implemented and serves the more
[rfc48.txt]:         basic function of testing whether a foreign NCP is alive.  We
[rfc48.txt]:         suggest that the length of the <ECO> command be variable, as
[rfc48.txt]:         there seems to be no significance in this context to 48 bits.
[rfc48.txt]:         Also, the value of a (presumably) 8 bit binary switch is
[rfc48.txt]:         Upon receipt of an <ECO> command the NCP would echo with the
[rfc48.txt]:         Simplicity and foresight notwithstanding, there will arise
[rfc48.txt]:         occasions when the level 2 protocol should change or be
[rfc48.txt]:         assigned to regular connections, with the remaining link
[rfc48.txt]:         replies, and this is in consonance with our view of the
[rfc48.txt]:         of the sites. We thus do not favor inclusion of Ancona's
[rfc48.txt]:         suggestion in NWG/RFC #42 for a message data type code as the
[rfc48.txt]:         first eight bits of the text of a message.
[rfc48.txt]:         purpose is to interface between the idiosyncratic structures
[rfc48.txt]:         internal structures corresponds to them.  Most systems do have
[rfc48.txt]:         such structures, however, so we shall continue to use them for
[rfc48.txt]:            We had been under the impression that all operating systems
[rfc48.txt]:            scanned for a reserved character from the keyboard to
[rfc48.txt]:            detected by the I/O channel hardware and passed to the
[rfc48.txt]:            Well over a year ago, we considered the problem of
[rfc48.txt]:            simulating console interrupts and rejected the <INT> type
[rfc48.txt]:            knew.  We now reverse our position and recommend the
[rfc48.txt]:            Two restrictions of the interrupt facility should be
[rfc48.txt]:            have interrupts. We recommend that systems follow their own
[rfc48.txt]:            which it shouldn't the <INT> should be discarded and
[rfc48.txt]:            the using process.  Standardization in this area should
[rfc48.txt]:            await further development.
[rfc48.txt]:            seems like the right thing, but we believe that such
[rfc48.txt]:            higher-level languages for the network.
[rfc48.txt]:         facility, i.e. <TER> and <BDC>.  We do not fully understand the
[rfc48.txt]:         statement on the relationship between OS/360 and the concepts
[rfc48.txt]:         and assumptions underlying the network protocol.
[rfc48.txt]:         _instance_ code which identifies the process attached to the
[rfc48.txt]:         be indistinguishable.  We did this with the belief that both as
[rfc48.txt]:         a Host whether a computation is performed by one or many
[rfc48.txt]:         within a job, these facilities mesh nicely with the current
[rfc48.txt]:         the basic philosophy of sockets and connections.  Presently we
[rfc48.txt]:         for the low order 8 bits of the socket.  We rejected _socket_
[rfc48.txt]:         The word socket should not be used as part of the field name,
[rfc48.txt]:   We assume that the typical host will have a time-sharing operating
[rfc48.txt]:   system in which the cpu is shared by processes.
[rfc48.txt]:   may be more than one process with the same user number, and if so,
[rfc48.txt]:   they should all be cooperating with respect to using the network.
[rfc48.txt]:   unique to the process.  These ports are used for input to or output
[rfc48.txt]:   from the process, from or to files, devices or other processes.
[rfc48.txt]:   mechanism to notify a process that some action external to the
[rfc48.txt]:   AEN, and a socket is local to a process if their user numbers match
[rfc48.txt]:   and they are in the same host.  A process need only specify an AEN
[rfc48.txt]:   concurrent events outside the process.  Whenever the status of a port
[rfc48.txt]:   is changed, the process is sent an event over its event channel which
[rfc48.txt]:   specifies which port's status has changed.  The process may then look
[rfc48.txt]:   However, these assumptions are not imposed by the network protocol
[rfc48.txt]:   and the implementation suggested by section IV is in no way binding.
[rfc48.txt]:   provide clues as to what the implementation difficulties might be and
[rfc48.txt]:   sockets as valid and queue them.  If desired, an NCP may reject them,
[rfc48.txt]:   as Meyer suggests, or it might hold them for awhile and reject them
[rfc48.txt]:   if they're not soon satisfied.  The offered protocol supports all
[rfc48.txt]:   these options.
[rfc48.txt]:   Another local option is the one mentioned before of attaching
[rfc48.txt]:   this may be ignored.  Similarly, the system calls are merely
[rfc48.txt]:   We show these only for completeness; each site will undoubtedly
[rfc48.txt]:        We use the notation
[rfc48.txt]:        Syscall is the system call
[rfc48.txt]:        arg  etc. are the parameters supplied with the call, and
[rfc48.txt]:        val etc. are any values returned by the system call.
[rfc48.txt]:        P      Specifies a port of the process.
[rfc48.txt]:        Bsiz   Specified the amount of storage in bits the user wants
[rfc48.txt]:   Init attempts to attach the local socket specified by AEN to the port
[rfc48.txt]:        C = ok      The Init was legal and the socket FS is being
[rfc48.txt]:                    contacted.  When the connection is established or
[rfc48.txt]:                    when FS refuses, the process will receive an event.
[rfc48.txt]:                    some other process with the same user number.  No
[rfc48.txt]:        C = homosex The AEN and FS were either both send or both receive
[rfc48.txt]:        P     Specifies a port of the process.
[rfc48.txt]:   The local socket specifies by AEN is attached to P.  If there is a
[rfc48.txt]:   waiting call, it is processed; otherwise no action is taken.  When a
[rfc48.txt]:   call comes in, a connection will be established and the process
[rfc48.txt]:        P Specifies a port of the process.
[rfc48.txt]:   Any activity is stopped, and the port becomes free for other use.
[rfc48.txt]:        L1    Specifies the length of the text.
[rfc48.txt]:   Transmission between the processes on either side of the port takes
[rfc48.txt]:                         otherwise uninhibited
[rfc48.txt]:   We view the NCP as having five component programs, three associative
[rfc48.txt]:         to-Host transmission into a resident buffer and wakes up the
[rfc48.txt]:         the Output Scheduler when transmission is complete.
[rfc48.txt]:         This program decides whether the input is a regular message
[rfc48.txt]:         or an error.  For each class of message, this program takes the
[rfc48.txt]:         Three classes of message are sent to the Imp
[rfc48.txt]:         We believe that a priority should be imposed among these
[rfc48.txt]:         classes.  The priority we suggest is the ordering above. The
[rfc48.txt]:         Output Scheduler selects the highest priority message and
[rfc48.txt]:         gives it to the Output Handler.
[rfc48.txt]:         This program interprets requests from the user.
[rfc48.txt]:   The two interesting components are the Input Interpreter and the
[rfc48.txt]:   System Call Interpreter.  These are similar in that the Input
[rfc48.txt]:   Interpreter services foreign requests and the System Call Interpreter
[rfc48.txt]:   We envision that the bulk of the NCP's data base is in three
[rfc48.txt]:   associative tables.  By "associative", we mean that there is some
[rfc48.txt]:   lookup routine which is presented with a key and either returns
[rfc48.txt]:   successfully with a pointer to the corresponding entry, or fails if
[rfc48.txt]:   no entry corresponds to the key.
[rfc48.txt]:         "Requests-for-connection" and other attributes of a
[rfc48.txt]:         local socket, but other tables have pointers to existing
[rfc48.txt]:            An entry is created when a user executes either an Init or a
[rfc48.txt]:            are unused until the connection is established, e.g. the
[rfc48.txt]:            foreign socket is not known until a <RFC> arrives if the
[rfc48.txt]:            The Input Interpreter uses the foreign host and link as a
[rfc48.txt]:            key to get a pointer to the entry in the rendezvous table
[rfc48.txt]:            for the connection using the incoming link.
[rfc48.txt]:            In order to interpret RFNM's, the Input Interpreter needs a
[rfc48.txt]:            table in the same form as the Input Link Table but using
[rfc48.txt]:   The following diagram is our conception of the Network Control
[rfc48.txt]:   represent component programs, the arrows represent data paths.
[rfc48.txt]:   The abbreviated names have the following meanings.
[rfc48.txt]:   IHBuf - Buffer filled by the Input Handler from the IMP and
[rfc48.txt]:           emptied by the Input Interpreter
[rfc48.txt]:   OHBuf - Buffer of outgoing messages filled from the Queues
[rfc48.txt]:           by the Output Scheduler and emptied by the Output
[rfc48.txt]:   [ into the online RFC archives by Donald and Jill Eastlake 1999 ]
[rfc49.txt]:   consensus of the Network Working Group at Project MAC are presented
[rfc49.txt]:   these.)
[rfc49.txt]:with Steve Crocker at UCLA relating to the network protocol,
[rfc49.txt]:later be recognized by the network participants.  However, because of a
[rfc49.txt]:lack of consensus, it will not be included in the initial
[rfc49.txt]:2) Steve supported the implementation of the INT network command
[rfc49.txt]:a socket connection to be reliably interrupted by the process at the
[rfc49.txt]:other end.  The interrupt causes a process to abey its current execution
[rfc49.txt]:and execute a procedure that it has specified as the INT handler.  (The
[rfc49.txt]:NCP does not specify the INT handler.  That is the function of higher
[rfc49.txt]:Under such a protocol, both the requestor and the created process agree
[rfc49.txt]:the NCP control link to the created process is the standard "quit"
[rfc49.txt]:interpretation of INT by other third level protocols.)
[rfc49.txt]:Although many systems implement the "quit" as a control character in the
[rfc49.txt]:Teletype input stream, systems such as CTSS, Multics, and others
[rfc49.txt]:implement it as a 200 ms spacing on the line.  We at MAC think that the
[rfc49.txt]:first method is an undesirable implementation within the network (while
[rfc49.txt]:the second is impossible).  I put forth several reasons why (and I think
[rfc49.txt]:(a) The link over which the quit character is to be transmitted may be
[rfc49.txt]:(b) While the interrupt is most effectively implemented within the NCP,
[rfc49.txt]:it is undesirable for the NCP to place any particular structure on the
[rfc49.txt]:if the NCP were to scan a data stream for a control character.
[rfc49.txt]:(c) Scanning the input stream greatly reduces NCP efficiency in a
[rfc49.txt]:Steve pointed out that the implementation of INT as a "quit" should not
[rfc49.txt]:the input stream from also acting as a "quit".
[rfc49.txt]:3) Steve is opposed both to including the instance tag in the socket
[rfc49.txt]:identifier and reserving a null field in the identifier for future
[rfc49.txt]:co-ordinated in joint action.  But what about the case where two
[rfc49.txt]:processes of the same user both want to independently use the network?)
[rfc49.txt]:does not know the instance tag of the particular process that he wants,
[rfc49.txt]:with some difficulty.  (I claim that something as fundamental as the
[rfc49.txt]:Tom stated that perhaps the low order three bits of the user code could
[rfc49.txt]:Steve's arguments seem to have merit.  Perhaps Tom's suggestion is the
[rfc49.txt]:4) We all (Steve and MAC) seem to agree that at the NCP level there
[rfc49.txt]:should be no special structure imposed on the data transmitted.  To an
[rfc49.txt]:happy result is that the difficult question of character sets does not
[rfc49.txt]:specification at the NCP level would delay agreement on the protocol and
[rfc49.txt]:make this character set more resistant to change.  (If there is to be a
[rfc49.txt]:standard character set, we prefer ASCII.  After all, it is the prefered
[rfc49.txt]:We also agree with Steve that there should be no optional echoing of
[rfc49.txt]:messages at the NCP protocol level.  (This is also the position of the
[rfc49.txt]:5) Shoshani, Long, and Landsberg also state (RFC 33) that they prefer to
[rfc49.txt]:automatically rejected via the CLS command.  Steve proposes that RFCs to
[rfc49.txt]:these sockets be briefly queued.  If the socket remains in an
[rfc49.txt]:unacceptable state for a specific interval after the RFC comes in, it is
[rfc49.txt]:connections to the requestor process and switching between them.
[rfc49.txt]:to the user whose process he wishes to create.  If these sockets are
[rfc49.txt]:inactive, the NCP automatically directs these requests to the foreign
[rfc49.txt]:HOST's logger process.  The logger accepts connection and performs the
[rfc49.txt]:login ritual.  If successful, the logger creates a user process and lets
[rfc49.txt]:go of the usurped sockets so that the created process may use them to
[rfc49.txt]:communicate with the requestor process.  (I note that this does not use
[rfc49.txt]:reconnection at a network level, since the logger uses sockets belonging
[rfc49.txt]:to the ultimate user.  However, it does involve internal reconnection.)
[rfc49.txt]:Tom and I objected to this because it introduces UCC protocol into the
[rfc49.txt]:proposals could be combined such that the requestor issues a
[rfc49.txt]:"signalling" RFC to a "signal" socket of the UCC process.  The UCC
[rfc49.txt]:rejects the RFC but remembers who is calling.  It then tries to connect
[rfc49.txt]:two sockets of the process to be created to the requestor's sockets, and
[rfc49.txt]:conducts the login ritual through these.  Steve liked this and suggested
[rfc49.txt]:Following the conversation, I thought of several disadvantages to this
[rfc49.txt]:(a) If the control sockets at a created process are limited to 0 and 1,
[rfc49.txt]:there is the possibility that a rightful user may not be able to
[rfc49.txt]:communicate with a foreign UCC because the UCC already is using those
[rfc49.txt]:and turn off the imposter, but this is an aggravating security breach.
[rfc49.txt]:the sockets and prevent access to a rightful user.  A better solution is
[rfc49.txt]:to allow any socket pair of the potential user process to act as the
[rfc49.txt]:control path.  This permits the UCC to conduct simultaneous
[rfc49.txt]:(b) A disadvantage of both Crocker's and the combined UCC is that the
[rfc49.txt]:particular user.  The logger must now make the additional check that the
[rfc49.txt]:user it is logging in actually belongs to the socket pair it is talking
[rfc49.txt]:over.  This seems the reverse of the prefered process: to identify a
[rfc49.txt]:user and then determine the user code for his socket identifiers.
[rfc49.txt]:(c) The user may not know the socket user code of the user he wishes to
[rfc49.txt]:log in at the foreign HOST.  (After all, there is no basic reason why
[rfc49.txt]:the requestor and created processes should have the same user code so
[rfc49.txt]:long as the requestor satisfies the foreign logger.)
[rfc49.txt]:(d) In the combined strategy, there is no way for the requestor to
[rfc49.txt]:specify which socket user code it wants.  The only assumption that the
[rfc49.txt]:UCC can make is that the requestor process wishes to log in a process
[rfc49.txt]:having the same socket user code as itself.  (This may not seem very
[rfc49.txt]:allow consoles attached to the local HOST to login at a foreign HOST
[rfc49.txt]:(e) The idea of allowing a process to masquerade within the network as
[rfc49.txt]:another process (even with the best of intentions) by using its socket
[rfc49.txt]:foreign process and another local process.
[rfc49.txt]:I still think that the UCC proposal we advanced in RFC 46 is a good
[rfc49.txt]:workable scheme.  It does not require socket reconnection (either
[rfc49.txt]:expressly throughout the network or implicitly within an NCP), nor do
[rfc49.txt]:any of the objections raised above apply.  The only particular
[rfc49.txt]:disadvantage I see is that it requires the requestor process to maintain
[rfc49.txt]:serious hindrance.  I would like the comments of the network
[rfc49.txt]:Fortunately the UCC is a third level protocol.  The second level NCP can
[rfc49.txt]:be specified before we reach final agreement on a UCC, provided that the
[rfc49.txt]:Steve expressed the thought that there need not be an initial standard
[rfc49.txt]:UCC, that there might be several UCCs.  We at MAC disagree.  If we are
[rfc49.txt]:all to talk to each other, and not between limited subsets of HOSTs
[rfc49.txt]:within the network, there must be an initial standard UCC which
[rfc49.txt]:EVERYBODY implements.  (Steve is of course correct that there can be
[rfc49.txt]:other experimental UCCs also implemented.)
[rfc49.txt]:It is theoretically possible for each HOST to provide multiple sets of
[rfc49.txt]:software to allow a requestor process to communicate with the loggers at
[rfc49.txt]:way in practice.  Each HOST will implement the UCC protocol that is most
[rfc49.txt]:I don't think that there is much enthusiasm at Project MAC for
[rfc49.txt]:       [ into the online RFC archives by Altair Petrofsky 7/97 ]
[rfc5.txt]:      feedback, and packing the resulting information into message 
[rfc5.txt]:      and accepting message packets from another computer, unpacking
[rfc5.txt]:      them, building trees of display information, and sending other
[rfc5.txt]:      information to the user at his interactive station.
[rfc5.txt]:   This is a working document for the evolution of the DEL language.
[rfc5.txt]:      It was generally agreed beforehand that the runmning of interactive
[rfc5.txt]:      programs across the network was the first problem that would be
[rfc5.txt]:      This group, already in agreement about the underlaying notions of
[rfc5.txt]:      At the meeting were Andrews, Baray, Carr, Crocker, Rulifson, and
[rfc5.txt]:   A second round of meetings was then held in a piecemeal way.
[rfc5.txt]:      resulted in the incorporation of formal co-routines.
[rfc5.txt]:   The first public release of this paper was at the BBN NET meeting in
[rfc5.txt]:   NST   The NST library is the set of programs necessary to mesh
[rfc5.txt]:   efficiently with the code compiled at the user sites from the DEL
[rfc5.txt]:   The lowest level of NST-DEL usage is direct transmission to the
[rfc5.txt]:   server-host, information in the same format that user programs
[rfc5.txt]:   would receive at the user-host.
[rfc5.txt]:      In this mode, the NST defaults to inaction.  The DEL program
[rfc5.txt]:      input in the normal fashion for the user-host.
[rfc5.txt]:      And the DEL 1 program becomes merely a message builder and
[rfc5.txt]:   TTY at the user-host.
[rfc5.txt]:      In this mode, the DEL program would run a full duplex TTY for
[rfc5.txt]:      the user.
[rfc5.txt]:      It would echo characters, translate them to the character set 
[rfc5.txt]:      of the server-host, pack the translated characters in messages,
[rfc5.txt]:      and on appropriate break characters send the messages.
[rfc5.txt]:      When messages come from the server-host, the DEL program would
[rfc5.txt]:      translate them to the user-host character set and print them on
[rfc5.txt]:   A more ambitious task for DEL is the operation of large,
[rfc5.txt]:   display-oriented systems from remote consoles over the NET.
[rfc5.txt]:      the user.  The unusual nature of the feedback make it
[rfc5.txt]:         This puts an unnecessarily large load on a TSS, and if the
[rfc5.txt]:         system is being run through the NET it could easily load two
[rfc5.txt]:         run on the user-host.  It will handle all the immediate
[rfc5.txt]:         button pushes, message will be sent to the server-host and
[rfc5.txt]:      One of the more difficult, and often neglected, problems is the
[rfc5.txt]:      effective simulation of one nonstandard console on another non-
[rfc5.txt]:         the co-routine structure of DEL programs.  For the
[rfc5.txt]:         complicated interactive systems, part of the DEL programs
[rfc5.txt]:         will be constructed by the server-host programmers.
[rfc5.txt]:         Interfaces between this program and the input stream may
[rfc5.txt]:         easily be inserted by programmers at the user-host site.
[rfc5.txt]:   To minimize the number of translators needed to map any facility's
[rfc5.txt]:   user codes to any other facility, there is a universal hardware
[rfc5.txt]:   This is simply a way of talking, in general terms, about all the
[rfc5.txt]:   hardware devices at all the interactive display stations in the initial
[rfc5.txt]:   For example, a display is thought of as being a square, the
[rfc5.txt]:   mid-point has coordinates (0.0), the range is -1 to 1 on both
[rfc5.txt]:   the particular number of density of rastor points on a display.
[rfc5.txt]:   The representation is discussed in the semantic explanations
[rfc5.txt]:   accompanying the formal description of DEL.
[rfc5.txt]:   Suppose that a user at a remote site, say Utah, is entered in the
[rfc5.txt]:   The first step is to enter NLS in the normal way.  At that time
[rfc5.txt]:   the Utah system will request a symbolic program from NLS.
[rfc5.txt]:      REP   This program is written in DEL.  It is called the NLS
[rfc5.txt]:      The program accepts input in the Universal Hardware
[rfc5.txt]:   When the program is first received at Utah it is compiled and
[rfc5.txt]:   All input from the Utah console first goes to the NLS NEP.  It is
[rfc5.txt]:   transfers to the 940.  The bits transferred are in a form
[rfc5.txt]:   acceptable to the 940, and maybe in a standard form so that the
[rfc5.txt]:   NLSW need not differentiate between Utah and other NET users.
[rfc5.txt]:   After each node has implemented the library part of the NST, it
[rfc5.txt]:   need only write one program for each subsystem, namely the
[rfc5.txt]:   symbolic file it sends to each user that maps the NET hardware
[rfc5.txt]:      This is the minimum programming that can be expected if 
[rfc5.txt]:      Since the NST which runs the encode translation is coded at the
[rfc5.txt]:      the fullest extent.  It can also add or remove hardware 
[rfc5.txt]:      from the host.
[rfc5.txt]:      Local users are also kept up to date on any changes in the system
[rfc5.txt]:      offered at the host site.  As new features are added,
[rfc5.txt]:      the host programmers change the symbolic encode program.  When
[rfc5.txt]:      this new program is compiled and used at the user site, the new
[rfc5.txt]:   The advantages of having the encode translation programs
[rfc5.txt]:      times and greater code density will be the result.
[rfc5.txt]:      Moreover, extra symbolic programs, coded at the user site, may
[rfc5.txt]:      be easily interfaced between the user's monitor system and the
[rfc5.txt]:      DEL program from the host machine.  This should ease the
[rfc5.txt]:      buttons) without loss of the flexibility needed for man-machine
[rfc5.txt]:   It is expected that when there is matching hardware, the symbolic
[rfc5.txt]:   computing.  This is immediately possible through the code
[rfc5.txt]:      The right side of the picture represents functions done at the
[rfc5.txt]:      user's main computer; the left side represents those done at the
[rfc5.txt]:         Each label in the picture corresponds to a statement with the
[rfc5.txt]:         links (in a forward direction) the labels which are concerned
[rfc5.txt]:         only with network information.  The second links the total
[rfc5.txt]:         are equivalent to the first two but in a backward direction.
[rfc5.txt]:   Keyboard is the set of input devices at the user's console.
[rfc5.txt]:   and interrupt handlers, eventually come to the encode translator.
[rfc5.txt]:   Encode maps the semi-raw input bits into an input stream in a
[rfc5.txt]:   form suited to the serving-host subsystem which will process the
[rfc5.txt]:      The Encode program was supplied by the server-host subsystem
[rfc5.txt]:      when the subsystem was first requested.  It is sent to the user
[rfc5.txt]:      machine in symbolic form and is compiled at the user machine
[rfc5.txt]:      give immediate feedback to the user.
[rfc5.txt]:   1 dm    Immediate feedback from the encode translator first goes to
[rfc5.txt]:   local display management, where it is mapped from the NET standard
[rfc5.txt]:   to the local display hardware.
[rfc5.txt]:      A wide range of echo output may come from the encode
[rfc5.txt]:      even done at the server-host user stations to be done in local
[rfc5.txt]:   Output from the encode translator for the server-host goes to the
[rfc5.txt]:   invisible IMP, is broken into appropriate sizes and labeled by the
[rfc5.txt]:   encode translator, and then goes to the NET-to-host translator.
[rfc5.txt]:      Output from the user may be more than on-line input.  It may be
[rfc5.txt]:      generated and used exclusively at the server-host site but
[rfc5.txt]:      stored at the user-host site.
[rfc5.txt]:      server-host format, or it may undergo yet another kind of translation
[rfc5.txt]:   hrp  It finally gets to the host, and must then go through the
[rfc5.txt]:   host reception program.  This maps and reorders the standard
[rfc5.txt]:   transmission-style packets of bits sent by the encode programs
[rfc5.txt]:   into messages acceptable to the host.  This program may well be
[rfc5.txt]:   part of the monitor of the host machine. [>tif(net mode)<nif(code)]
[rfc5.txt]:   decode   Output from the server-host initially goes through decode,
[rfc5.txt]:   the encode map.  [>nif(urt)>tif(imp ctrl)<tif(net mode)]
[rfc5.txt]:      dealt with in various ways at the user site.
[rfc5.txt]:         The Decode program was sent to the host machine at the same
[rfc5.txt]:         time that the Encode program was sent to the user machine.
[rfc5.txt]:         for efficient running at the host machine.
[rfc5.txt]:         different line widths can be handled at the user site.
[rfc5.txt]:         For example, if a straight line is to be drawn across the
[rfc5.txt]:         display this fact should be transmitted, rather than a
[rfc5.txt]:         display information (in the manner of LEAP) should be sent
[rfc5.txt]:         and accommodated at user sites so that the responsibility for
[rfc5.txt]:         real-time display manipulation may shift closer to the user.
[rfc5.txt]:      the host decoder.  [>tif(urt) <tif(decode)]
[rfc5.txt]:      The other control information supplied by the host decoder is
[rfc5.txt]:      sorting can be done at the user site.
[rfc5.txt]:   From the host decoder, information does to the invisible IMP, and
[rfc5.txt]:   directly to the NET-to-user translator.  The only operation done
[rfc5.txt]:   on the messages is that they may be shuffled.
[rfc5.txt]:   urt   The user reception translator accepts messages from the
[rfc5.txt]:   user-site IMP 1 and fixes them up for user-site display.  
[rfc5.txt]:      The minimal action is a reordering of the message pieces.
[rfc5.txt]:      NET logical display information must be put in the format of
[rfc5.txt]:      the user site.  Display control does this job.  Since it
[rfc5.txt]:      features of display management local to the user site.
[rfc5.txt]:      prgmctrl   Another action may be the selective translation and
[rfc5.txt]:         compact binary format suitable for quick translation, rather
[rfc5.txt]:      (display)   is the output to the user.  [<nif(d ctrl)]
[rfc5.txt]:      (net mode)   This is the mode where a remote user can link to a node
[rfc5.txt]:      indirectly through another node.   [<nif(decode)<tif(hrt)]
[rfc5.txt]:      All statements in this branch which are not part of the compiler
[rfc5.txt]:      To compile the DEL compiler:
[rfc5.txt]:         Set this pattern for the content analyzer ( (symbol for up arrow)P1
[rfc5.txt]:         SE(P1) <-"-;). The pointer "del" is on the first character of pattern.
[rfc5.txt]:         Jump to the first statement of the compiler.  The pointer "c"
[rfc5.txt]:         And output the compiler to file  ( '/A-DEL' ).  The pointer "f"
[rfc5.txt]:         is on the name of the file for the compiler output -
[rfc5.txt]:      envocation points are given the pipe declaration.
[rfc5.txt]:   The label declaration is to declare cells which may contain the
[rfc5.txt]:   machine addresses of labels in the program as their values.  This 
[rfc5.txt]:   is not the B5500 label declaration.
[rfc5.txt]:   In the pipe declaration the first .ID of each pair is the name of
[rfc5.txt]:   the pipe, the second is thke initial starting point for the pipe.
[rfc5.txt]:   Notice that the uniary minus is allowable, and parsed so you can
[rfc5.txt]:   Since there is no standard convention with bitwise operators, they
[rfc5.txt]:   all have the same precedence, and parentheses must be used for
[rfc5.txt]:   Compliment is the l's compliment.
[rfc5.txt]:   the mode and style of the machine running the code.  Anyone who
[rfc5.txt]:   parenthesized expressions may be a series of expressions.  The
[rfc5.txt]:   value of a series is the value of the last one executed at run time.
[rfc5.txt]:   using jumps in the code.  Reference to the conjunct is made only
[rfc5.txt]:   unnecessary evaluations at run time.  I.e a conjunct in which the
[rfc5.txt]:   left part is false or a disjunct with the left part true need not
[rfc5.txt]:   have the corresponding right part evaluated.
[rfc5.txt]:   An expressions may be a statement.  In conditional statements the
[rfc5.txt]:   is a side effect of the way the left part of the syntax rules are
[rfc5.txt]:         (("left" / "right") "brother") /
[rfc5.txt]:   Extra parentheses in tree building results in linear subcategorization,
[rfc5.txt]:      the named co-routine.
[rfc5.txt]:      For statements evaluate their initial exp, by part, and to part
[rfc5.txt]:      statements is not available for change within the loop, it may
[rfc5.txt]:      (say put it in a register) all the better.  The increment and
[rfc5.txt]:      the to bound will both be rounded to integers during the
[rfc5.txt]:   The value of a case statement is the value of the last case executed.
[rfc5.txt]:      Associated with the screen is a position register, called
[rfc5.txt]:      specify a point on the screen and r is a rotation in
[rfc5.txt]:      radians, counter clockwise, from the x-axis.
[rfc5.txt]:      The intensity, called INTENSITY, is a real number in the
[rfc5.txt]:      display can go, and numbers in between specify the relative
[rfc5.txt]:      log of the intensity difference.
[rfc5.txt]:      The terminal nodes of semi-trees are either semi-tree names
[rfc5.txt]:      When the buffer is initilized, it is empty.  If no
[rfc5.txt]:      parameters are initially appended, those in effect at the
[rfc5.txt]:      end of the display of the last node in the semi-tree will be in
[rfc5.txt]:      effect for the display of this node.
[rfc5.txt]:      As the buffer is built, the logical entities are added to it.
[rfc5.txt]:      When it is established as a buffername, the buffer is
[rfc5.txt]:      closed, and further appends are prohibited.  It is only a
[rfc50.txt]:                     Comments on the Meyer Proposal
[rfc50.txt]:We find the Meyer proposal (Note #46) to be the most acceptable
[rfc50.txt]:to dare, for exactly the reasons that he enumerates; viz., simple,
[rfc50.txt]:suffices for most planned uses of the Network, easy to implement,
[rfc50.txt]:suggested recently, however, we do agree with the items that are
[rfc50.txt]:proposed and we feel that the missing features are probably not
[rfc50.txt]:worth doing battle over and thus delaying the specification.
[rfc50.txt]:We make the following comments on the seven issues rasied in
[rfc50.txt]:       be required for more sophisticated uses of the Network.
[rfc50.txt]:       We also agree with the Project MAC people that it
[rfc50.txt]:       reconnection given some Network experience and the specific
[rfc50.txt]:       We see the need for both cases; a) where multiple processes
[rfc50.txt]:       them.  Those program parts that should not distinguish
[rfc50.txt]:       among processes should simply ignore the instance tag.
[rfc50.txt]:       Tom's suggestion to use part of the user number sub-field
[rfc50.txt]:       merely reduces the combined length of sub-fields from 32
[rfc50.txt]:       bits to 24 bits; the problem remains.
[rfc50.txt]:       structure should be imposed on the data transmitted.  We
[rfc50.txt]:       prefer the "message data type" mentioned by E. I. Ancona,
[rfc50.txt]:       support adopting one in the beginning, and in particular
[rfc50.txt]:       suggested ASCII.  Is there anyone who objects?
[rfc50.txt]:   7)  We support the UCC in Note #46 for three principle reasons:
[rfc50.txt]:       a)  In general the user should not know the remote socket
[rfc50.txt]:           code of the process to whom he wishes to communicate.
[rfc50.txt]:           in conjunction with the interrupt procedure.
[rfc50.txt]:       c)  Most of the other proposed methods demand queueing.
[rfc50.txt]:      We think there must be a standard UCC, yet we encourage
[rfc50.txt]:they do not deny multiplexing over a given link.  With regard to
[rfc50.txt]:the use of links, we refer to an example given by Bob Kahn where
[rfc50.txt]:In Note #46, page 6, the statement that the UCC has the ability
[rfc50.txt]:In our particular case the NCP is notified directly of process
[rfc50.txt]:failure due to the particular software interface through which all
[rfc50.txt]:          [ into the online RFC archives by Gary Okada 7/97 ]
[rfc6.txt]:in the IMP's, IMP-HOST communication, and HOST software.
[rfc6.txt]:ASCII for transmission and convert again upon assembly at the destination
[rfc6.txt]:IMP.  BB&N plans a one for one conversion scheme with tables unique to the
[rfc6.txt]:This would allow another handle for checking or controlling the system.
[rfc6.txt]:        3.  Whether message is for destination IMP or HOST
[rfc6.txt]:I also summarized for Bob the contents of Network Notes l, 2, and 3.
[rfc7.txt]:   II.  Scope of the software organization.
[rfc7.txt]:   copies exist.  RFC 7 was later typed int NLS by the Augmentation
[rfc7.txt]:   Research Center (ARC) at SRI.  The following is the best
[rfc7.txt]:   This paper is concerned with the preliminary software design of the
[rfc7.txt]:   Host IMP interface.  Its main purpose is on the one hand to define
[rfc7.txt]:   functions that will be implemented, and on the other hand to provide
[rfc7.txt]:   This study is based upon a study of the BBN Report No. 763.
[rfc7.txt]:II.  Scope of the software organization.
[rfc7.txt]:   The system is based upon two main programs: the Handler program that
[rfc7.txt]:   drives the channel hardware unit, and the Network program which
[rfc7.txt]:   carries out the user's transmission requests.
[rfc7.txt]:   As the communication is full duplex, each of these programs can be
[rfc7.txt]:   viewed as divided into two parts: one is concerned with the output
[rfc7.txt]:   data, the other with the input. (See Fig. 1)
[rfc7.txt]:   In the following we only focus on the output part of each program
[rfc7.txt]:   This program multiplexes the outgoing messages (and distributes the
[rfc7.txt]:   incoming messages).  The multiplexing consists in stacking up all the
[rfc7.txt]:   user's (or caller, or party) requests and filling up the pool of
[rfc7.txt]:   buffers so as to keep the handler busy emitting.
[rfc7.txt]:   Multiplexing (and distribution) is based on the link identification
[rfc7.txt]:   multiplexing problem is closely related to the interface between a
[rfc7.txt]:   user's program and the network program, that is in
[rfc7.txt]:   When a user's program wants to send out text it should indicate the
[rfc7.txt]:   Using these data the Network program:
[rfc7.txt]:      *  inserts a 16 bits marking between the header and the text so as
[rfc7.txt]:         to start the text at a word boundary.  This marking consists of
[rfc7.txt]:         a one preceding the first bit of the text and, in turn,
[rfc7.txt]:         preceded by fifteen zeros to fill up the gap.
[rfc7.txt]:      *  checks the length of the user's text - if it exceeds 1006 bytes
[rfc7.txt]:   the program breaks down the text into a sequence of messages whose
[rfc7.txt]:   maximum length is 1006 bytes - Each of these messages is preceded by
[rfc7.txt]:   Remark: in that case one of the heading space bits could be used for
[rfc7.txt]:   indicating that several messages belong to the same text.
[rfc7.txt]:      *  _transcodes_ the EBCDIC characters constituting the messages
[rfc7.txt]:      *  _fills_ the buffers of the pool with the content of the
[rfc7.txt]:      *  _updates_ the content of the interface table and moves the
[rfc7.txt]:   This program is initiated either by the network program, or by the
[rfc7.txt]:   (privileged instructions) and should be integrated in the I/O
[rfc7.txt]:   supervisor of the operating system.
[rfc7.txt]:      *  _controls_ the channel hardware unit.  It initiates the
[rfc7.txt]:         emission, eventually provides data chaining between the
[rfc7.txt]:         buffers, tests the different device status upon receiving an
[rfc7.txt]:      *  _empties_ the buffers that are filled up by the network
[rfc7.txt]:      *  _explores_ and _updates_ the interface table (see below).
[rfc7.txt]:      *  can eventually insure a control transmission procedure with the
[rfc7.txt]:   They should be large enough for containing the maximum host message
[rfc7.txt]:   Consequently the buffer size could be chosen equal to 256 words (1024
[rfc7.txt]:   bytes).  As for the buffer number it will determine the link
[rfc7.txt]:   It is through this table that the network program informs the handler
[rfc7.txt]:   with the location and length of the emitting data.
[rfc7.txt]:   the other for extracting.  They are respectively updated by the
[rfc7.txt]:   network and the handler program.
[rfc7.txt]:                      [Length] of the message
[rfc7.txt]:                           in the buffer
[rfc7.txt]:III-1.  Why is there not a simple control procedure between the HOST and
[rfc7.txt]:        the IMP?  What happens if a message, issued from the HOST,
[rfc7.txt]:        reaches the IMP with an error due to the transmission?
[rfc7.txt]:   From the BBN specifications it appears that this error will be
[rfc7.txt]:   transmitted as far [as] the receiving HOST.
[rfc7.txt]:III-2.  Where will the special channel hardware unit be connected
[rfc7.txt]:   to start the padding?
[rfc7.txt]:   (The program will provide to the MIOP SIOP the number of bytes of the
[rfc7.txt]:   outgoing message, and will receive back an interrupt when the last
[rfc7.txt]:   byte is sent out.  Is it that signal which will be also sent to the
[rfc7.txt]:   Vice versa how does the Handler know the length of the incoming
[rfc7.txt]:   message?  From the contents of the previous one or should this
[rfc7.txt]:   an interrupt should be triggered when the real end is detected by the
[rfc7.txt]:III-3.  When does the Gordo documentation will be available in order to
[rfc7.txt]:        design the user-network program interface.  What are the
[rfc7.txt]:        one program to another, etc...
[rfc7.txt]:   [ into the online RFC archives by Bob German & Lorrie Shiota 1/02 ]
